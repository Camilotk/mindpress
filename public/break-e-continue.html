<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aula 10: Break e Continue</title>
  <link rel="stylesheet" href="themes/rustbook/css/water-dark.css">
  <link rel="stylesheet" href="themes/rustbook/css/theme.css">
  <script src="themes/rustbook/js/theme.js" defer></script>
</head>
<body>

<aside>
  <header><h1>Curso de Algoritmos com Go</h1></header>
  <nav aria-label="Conte√∫do do curso">
    <ul>
      <li><a href="index.html">üìö √çndice Geral</a></li>
      <li><a href="algoritmos-base.html">Aula 1: Algoritmos ‚Äì A Base de Tudo!</a></li>
      <li><a href="break-e-continue.html">Aula 10: Break e Continue</a></li>
      <li><a href="condicional-if-else.html">Aula 6: Condicional If/Else</a></li>
      <li><a href="condicional-switch.html">Aula 7: Condicional Switch</a></li>
      <li><a href="entrada-e-saida.html">Aula 4: Entrada e Sa√≠da com Go</a></li>
      <li><a href="estrutura-sequencial.html">Aula 5: Estrutura Sequencial</a></li>
      <li><a href="identificadores-operadores.html">Aula 3: Identificadores e Operadores</a></li>
      <li><a href="nova_aula.html">Nova aula</a></li>
      <li><a href="repeticao-for.html">Aula 8: Repeti√ß√£o com For</a></li>
      <li><a href="variaveis-e-tipos.html">Aula 2: Vari√°veis e Tipos de Dados em Go</a></li>
      <li><a href="while-com-for.html">Aula 9: While com For</a></li>
    </ul>
  </nav>
</aside>

<main>
  <article>
    <h2>Aula 10: Break e Continue</h2>
    <nav class="minimap"><ul><li class="lvl2"><a href="#objetivos-da-aula">Objetivos da Aula</a></li><li class="lvl2"><a href="#1-introdu√ß√£o-ao-controle-de-fluxo-em-la√ßos">1. Introdu√ß√£o ao Controle de Fluxo em La√ßos</a></li><li class="lvl3"><a href="#1-1-o-que-√©-controle-de-fluxo">1.1. O que √© Controle de Fluxo?</a></li><li class="lvl3"><a href="#1-2-por-que-precisamos-de-controle-de-fluxo-adicional">1.2. Por que Precisamos de Controle de Fluxo Adicional?</a></li><li class="lvl2"><a href="#2-a-instru√ß√£o-code-break-code">2. A Instru√ß√£o <code>break</code></a></li><li class="lvl3"><a href="#2-1-o-que-√©-code-break-code">2.1. O que √© <code>break</code>?</a></li><li class="lvl3"><a href="#2-2-sintaxe-e-funcionamento">2.2. Sintaxe e Funcionamento</a></li><li class="lvl3"><a href="#2-3-exemplos-b√°sicos">2.3. Exemplos B√°sicos</a></li><li class="lvl3"><a href="#2-4-casos-de-uso-comuns-para-code-break-code">2.4. Casos de Uso Comuns para <code>break</code></a></li><li class="lvl2"><a href="#3-a-instru√ß√£o-code-continue-code">3. A Instru√ß√£o <code>continue</code></a></li><li class="lvl3"><a href="#3-1-o-que-√©-code-continue-code">3.1. O que √© <code>continue</code>?</a></li><li class="lvl3"><a href="#3-2-sintaxe-e-funcionamento">3.2. Sintaxe e Funcionamento</a></li><li class="lvl3"><a href="#3-3-exemplos-b√°sicos">3.3. Exemplos B√°sicos</a></li><li class="lvl3"><a href="#3-4-casos-de-uso-comuns-para-code-continue-code">3.4. Casos de Uso Comuns para <code>continue</code></a></li><li class="lvl2"><a href="#4-diferen√ßas-entre-code-break-code-e-code-continue-code">4. Diferen√ßas entre <code>break</code> e <code>continue</code></a></li><li class="lvl3"><a href="#4-1-escolhendo-entre-code-break-code-e-code-continue-code">4.1. Escolhendo entre <code>break</code> e <code>continue</code></a></li><li class="lvl2"><a href="#5-controle-de-fluxo-em-la√ßos-aninhados">5. Controle de Fluxo em La√ßos Aninhados</a></li><li class="lvl3"><a href="#5-1-code-break-code-e-code-continue-code-em-la√ßos-aninhados">5.1. <code>break</code> e <code>continue</code> em La√ßos Aninhados</a></li><li class="lvl3"><a href="#5-2-usando-r√≥tulos-labels-para-controle-avan√ßado">5.2. Usando R√≥tulos (Labels) para Controle Avan√ßado</a></li><li class="lvl3"><a href="#5-3-exemplo-pr√°tico-busca-em-matriz">5.3. Exemplo Pr√°tico: Busca em Matriz</a></li><li class="lvl2"><a href="#6-aplica√ß√µes-pr√°ticas">6. Aplica√ß√µes Pr√°ticas</a></li><li class="lvl3"><a href="#6-1-valida√ß√£o-de-entrada-com-code-break-code">6.1. Valida√ß√£o de Entrada com <code>break</code></a></li><li class="lvl3"><a href="#6-2-processamento-de-lista-com-code-continue-code">6.2. Processamento de Lista com <code>continue</code></a></li><li class="lvl3"><a href="#6-3-busca-eficiente-com-code-break-code">6.3. Busca Eficiente com <code>break</code></a></li><li class="lvl3"><a href="#6-4-processamento-de-texto-com-code-continue-code">6.4. Processamento de Texto com <code>continue</code></a></li><li class="lvl2"><a href="#7-boas-pr√°ticas">7. Boas Pr√°ticas</a></li><li class="lvl3"><a href="#7-1-use-code-break-code-e-code-continue-code-com-modera√ß√£o">7.1. Use <code>break</code> e <code>continue</code> com Modera√ß√£o</a></li><li class="lvl3"><a href="#7-2-prefira-condi√ß√µes-claras">7.2. Prefira Condi√ß√µes Claras</a></li><li class="lvl3"><a href="#7-3-evite-la√ßos-aninhados-profundos-com-r√≥tulos">7.3. Evite La√ßos Aninhados Profundos com R√≥tulos</a></li><li class="lvl3"><a href="#7-4-documente-o-prop√≥sito">7.4. Documente o Prop√≥sito</a></li><li class="lvl3"><a href="#7-5-considere-alternativas">7.5. Considere Alternativas</a></li><li class="lvl2"><a href="#8-exerc√≠cios-offline">8. Exerc√≠cios Offline</a></li><li class="lvl2"><a href="#9-quiz-r√°pido">9. Quiz R√°pido</a></li><li class="lvl2"><a href="#10-desafio-pr√°tico-processador-de-texto">10. Desafio Pr√°tico: Processador de Texto</a></li><li class="lvl2"><a href="#11-resumo-da-aula">11. Resumo da Aula</a></li><li class="lvl2"><a href="#12-ficha-de-refer√™ncia-r√°pida">12. Ficha de Refer√™ncia R√°pida</a></li><li class="lvl3"><a href="#instru√ß√µes-de-controle-de-fluxo">Instru√ß√µes de Controle de Fluxo</a></li><li class="lvl3"><a href="#casos-de-uso-comuns">Casos de Uso Comuns</a></li><li class="lvl3"><a href="#padr√µes-comuns">Padr√µes Comuns</a></li><li class="lvl2"><a href="#13-modelos-de-c√≥digo">13. Modelos de C√≥digo</a></li><li class="lvl3"><a href="#modelo-1-busca-com-code-break-code">Modelo 1: Busca com <code>break</code></a></li><li class="lvl3"><a href="#modelo-2-filtragem-com-code-continue-code">Modelo 2: Filtragem com <code>continue</code></a></li><li class="lvl3"><a href="#modelo-3-valida√ß√£o-de-entrada-com-code-break-code">Modelo 3: Valida√ß√£o de Entrada com <code>break</code></a></li><li class="lvl3"><a href="#modelo-4-la√ßos-aninhados-com-r√≥tulos">Modelo 4: La√ßos Aninhados com R√≥tulos</a></li></ul></nav><h1>Aula 10: Controle de Fluxo Dentro de La√ßos: <code>break</code> e <code>continue</code> em Go</h1>
<h2 id="objetivos-da-aula">Objetivos da Aula</h2>
<p>Ao final desta aula, voc√™ ser√° capaz de:</p>
<ul>
<li>Compreender o prop√≥sito e funcionamento das instru√ß√µes <code>break</code> e <code>continue</code></li>
<li>Utilizar <code>break</code> para sair prematuramente de um la√ßo</li>
<li>Utilizar <code>continue</code> para pular para a pr√≥xima itera√ß√£o de um la√ßo</li>
<li>Implementar controle de fluxo eficiente em la√ßos para resolver problemas</li>
<li>Criar programas em Go que utilizam <code>break</code> e <code>continue</code> para otimizar a execu√ß√£o</li>
</ul>
<hr />
<h2 id="1-introdu√ß√£o-ao-controle-de-fluxo-em-la√ßos">1. Introdu√ß√£o ao Controle de Fluxo em La√ßos</h2>
<h3 id="1-1-o-que-√©-controle-de-fluxo">1.1. O que √© Controle de Fluxo?</h3>
<p>O <strong>controle de fluxo</strong> refere-se √† capacidade de alterar a ordem de execu√ß√£o das instru√ß√µes em um programa. Em la√ßos, o fluxo normal √© executar todas as instru√ß√µes dentro do bloco e, em seguida, verificar a condi√ß√£o para decidir se o la√ßo deve continuar ou terminar.</p>
<p>No entanto, h√° situa√ß√µes em que precisamos:
- Sair de um la√ßo antes que sua condi√ß√£o normal de t√©rmino seja atingida
- Pular o restante das instru√ß√µes na itera√ß√£o atual e avan√ßar para a pr√≥xima itera√ß√£o</p>
<p>Go fornece duas instru√ß√µes especiais para esses casos: <code>break</code> e <code>continue</code>.</p>
<h3 id="1-2-por-que-precisamos-de-controle-de-fluxo-adicional">1.2. Por que Precisamos de Controle de Fluxo Adicional?</h3>
<p>O controle de fluxo adicional em la√ßos nos permite:</p>
<ol>
<li><strong>Otimizar a execu√ß√£o</strong>: Evitar processamento desnecess√°rio quando j√° encontramos o que procur√°vamos.</li>
<li><strong>Lidar com casos especiais</strong>: Tratar situa√ß√µes excepcionais sem complicar a l√≥gica principal.</li>
<li><strong>Implementar algoritmos complexos</strong>: Criar estruturas de controle mais sofisticadas.</li>
<li><strong>Melhorar a legibilidade</strong>: Expressar inten√ß√µes de forma mais clara em certos algoritmos.</li>
</ol>
<p>Pense em situa√ß√µes do cotidiano:
- Voc√™ est√° procurando suas chaves em v√°rias gavetas. Assim que as encontra, <strong>para</strong> de procurar (similar ao <code>break</code>).
- Ao verificar uma lista de compras, se um item estiver indispon√≠vel, voc√™ <strong>continua</strong> para o pr√≥ximo item (similar ao <code>continue</code>).</p>
<hr />
<h2 id="2-a-instru√ß√£o-code-break-code">2. A Instru√ß√£o <code>break</code></h2>
<h3 id="2-1-o-que-√©-code-break-code">2.1. O que √© <code>break</code>?</h3>
<p>A instru√ß√£o <code>break</code> √© usada para sair imediatamente de um la√ßo, independentemente da condi√ß√£o de t√©rmino normal. Quando o Go encontra um <code>break</code>, ele interrompe a execu√ß√£o do la√ßo e continua com o c√≥digo ap√≥s o bloco do la√ßo.</p>
<h3 id="2-2-sintaxe-e-funcionamento">2.2. Sintaxe e Funcionamento</h3>
<pre><code class="language-go">for condi√ß√£o {
    // C√≥digo

    if outraCondi√ß√£o {
        break // Sai do la√ßo imediatamente
    }

    // Este c√≥digo n√£o ser√° executado se o break for acionado
}
// A execu√ß√£o continua aqui ap√≥s o break
</code></pre>
<h3 id="2-3-exemplos-b√°sicos">2.3. Exemplos B√°sicos</h3>
<p><strong>Exemplo 1: Encontrar o primeiro n√∫mero divis√≠vel por 7</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    for i := 1; i &lt;= 100; i++ {
        fmt.Printf(&quot;Verificando %d...\n&quot;, i)

        if i%7 == 0 {
            fmt.Printf(&quot;Encontrado! %d √© divis√≠vel por 7\n&quot;, i)
            break
        }
    }

    fmt.Println(&quot;Busca conclu√≠da&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Verificando 1...
Verificando 2...
Verificando 3...
Verificando 4...
Verificando 5...
Verificando 6...
Verificando 7...
Encontrado! 7 √© divis√≠vel por 7
Busca conclu√≠da
</code></pre>
<p>Neste exemplo, o la√ßo iria normalmente de 1 a 100, mas usamos <code>break</code> para sair assim que encontramos o primeiro n√∫mero divis√≠vel por 7.</p>
<p><strong>Exemplo 2: Valida√ß√£o de entrada</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Digite n√∫meros positivos (digite um n√∫mero negativo para sair):&quot;)

    for {
        var numero int
        fmt.Print(&quot;N√∫mero: &quot;)
        fmt.Scanln(&amp;numero)

        if numero &lt; 0 {
            fmt.Println(&quot;N√∫mero negativo detectado. Saindo...&quot;)
            break
        }

        fmt.Printf(&quot;Voc√™ digitou: %d\n&quot;, numero)
    }

    fmt.Println(&quot;Programa encerrado&quot;)
}
</code></pre>
<p>Neste exemplo, usamos um la√ßo infinito (<code>for { ... }</code>) e <code>break</code> para sair quando o usu√°rio digita um n√∫mero negativo.</p>
<h3 id="2-4-casos-de-uso-comuns-para-code-break-code">2.4. Casos de Uso Comuns para <code>break</code></h3>
<ol>
<li><strong>Busca em cole√ß√µes</strong>: Sair do la√ßo assim que encontrar o item procurado.</li>
<li><strong>Valida√ß√£o de entrada</strong>: Continuar pedindo entrada at√© receber um valor v√°lido.</li>
<li><strong>Processamento condicional</strong>: Processar dados at√© que uma condi√ß√£o espec√≠fica seja atendida.</li>
<li><strong>Menus interativos</strong>: Sair do menu quando o usu√°rio escolher a op√ß√£o de sa√≠da.</li>
<li><strong>Algoritmos de otimiza√ß√£o</strong>: Interromper a busca quando a solu√ß√£o √≥tima for encontrada.</li>
</ol>
<hr />
<h2 id="3-a-instru√ß√£o-code-continue-code">3. A Instru√ß√£o <code>continue</code></h2>
<h3 id="3-1-o-que-√©-code-continue-code">3.1. O que √© <code>continue</code>?</h3>
<p>A instru√ß√£o <code>continue</code> √© usada para pular o restante do c√≥digo na itera√ß√£o atual de um la√ßo e avan√ßar para a pr√≥xima itera√ß√£o. Diferentemente do <code>break</code>, o <code>continue</code> n√£o sai do la√ßo; ele apenas pula para a pr√≥xima repeti√ß√£o.</p>
<h3 id="3-2-sintaxe-e-funcionamento">3.2. Sintaxe e Funcionamento</h3>
<pre><code class="language-go">for condi√ß√£o {
    // C√≥digo antes do continue

    if outraCondi√ß√£o {
        continue // Pula para a pr√≥xima itera√ß√£o
    }

    // Este c√≥digo ser√° ignorado quando o continue for acionado
}
</code></pre>
<h3 id="3-3-exemplos-b√°sicos">3.3. Exemplos B√°sicos</h3>
<p><strong>Exemplo 1: Imprimir apenas n√∫meros √≠mpares</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;N√∫meros √≠mpares de 1 a 10:&quot;)

    for i := 1; i &lt;= 10; i++ {
        if i%2 == 0 {
            continue // Pula os n√∫meros pares
        }

        fmt.Println(i)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>N√∫meros √≠mpares de 1 a 10:
1
3
5
7
9
</code></pre>
<p>Neste exemplo, usamos <code>continue</code> para pular a impress√£o quando o n√∫mero √© par.</p>
<p><strong>Exemplo 2: Processamento condicional de uma lista</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    nomes := []string{&quot;Ana&quot;, &quot;&quot;, &quot;Carlos&quot;, &quot;Diana&quot;, &quot;&quot;, &quot;Eduardo&quot;}

    fmt.Println(&quot;Nomes v√°lidos:&quot;)

    for i := 0; i &lt; len(nomes); i++ {
        if nomes[i] == &quot;&quot; {
            continue // Pula strings vazias
        }

        fmt.Printf(&quot;%d: %s\n&quot;, i, nomes[i])
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Nomes v√°lidos:
0: Ana
2: Carlos
3: Diana
5: Eduardo
</code></pre>
<p>Neste exemplo, usamos <code>continue</code> para pular o processamento de strings vazias na lista.</p>
<h3 id="3-4-casos-de-uso-comuns-para-code-continue-code">3.4. Casos de Uso Comuns para <code>continue</code></h3>
<ol>
<li><strong>Filtragem de dados</strong>: Pular itens que n√£o atendem a certos crit√©rios.</li>
<li><strong>Tratamento de casos especiais</strong>: Ignorar casos excepcionais sem complicar a l√≥gica principal.</li>
<li><strong>Otimiza√ß√£o de processamento</strong>: Evitar c√°lculos desnecess√°rios para certos valores.</li>
<li><strong>Valida√ß√£o em m√∫ltiplas etapas</strong>: Pular para o pr√≥ximo item se a valida√ß√£o falhar em qualquer etapa.</li>
<li><strong>Processamento de listas com valores nulos</strong>: Ignorar valores nulos ou vazios.</li>
</ol>
<hr />
<h2 id="4-diferen√ßas-entre-code-break-code-e-code-continue-code">4. Diferen√ßas entre <code>break</code> e <code>continue</code></h2>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th><code>break</code></th>
<th><code>continue</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Efeito</td>
<td>Sai completamente do la√ßo</td>
<td>Pula para a pr√≥xima itera√ß√£o</td>
</tr>
<tr>
<td>C√≥digo ap√≥s a instru√ß√£o</td>
<td>N√£o √© executado</td>
<td>N√£o √© executado</td>
</tr>
<tr>
<td>C√≥digo ap√≥s o la√ßo</td>
<td>√â executado imediatamente</td>
<td>√â executado ap√≥s todas as itera√ß√µes</td>
</tr>
<tr>
<td>Uso t√≠pico</td>
<td>Quando encontramos o que procuramos</td>
<td>Quando queremos ignorar certos valores</td>
</tr>
<tr>
<td>Efeito na condi√ß√£o do la√ßo</td>
<td>Ignora a condi√ß√£o e sai</td>
<td>A condi√ß√£o ainda √© verificada na pr√≥xima itera√ß√£o</td>
</tr>
</tbody>
</table>
<h3 id="4-1-escolhendo-entre-code-break-code-e-code-continue-code">4.1. Escolhendo entre <code>break</code> e <code>continue</code></h3>
<ul>
<li>Use <code>break</code> quando quiser <strong>terminar</strong> completamente o processamento do la√ßo.</li>
<li>Use <code>continue</code> quando quiser <strong>pular</strong> apenas a itera√ß√£o atual, mas continuar o la√ßo.</li>
</ul>
<p><strong>Exemplo comparativo:</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Demonstra√ß√£o com break:&quot;)
    for i := 1; i &lt;= 5; i++ {
        if i == 3 {
            fmt.Println(&quot;  Encontrei 3, saindo do la√ßo com break&quot;)
            break
        }
        fmt.Printf(&quot;  Processando %d\n&quot;, i)
    }
    fmt.Println(&quot;La√ßo com break terminou\n&quot;)

    fmt.Println(&quot;Demonstra√ß√£o com continue:&quot;)
    for i := 1; i &lt;= 5; i++ {
        if i == 3 {
            fmt.Println(&quot;  Encontrei 3, pulando com continue&quot;)
            continue
        }
        fmt.Printf(&quot;  Processando %d\n&quot;, i)
    }
    fmt.Println(&quot;La√ßo com continue terminou&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Demonstra√ß√£o com break:
  Processando 1
  Processando 2
  Encontrei 3, saindo do la√ßo com break
La√ßo com break terminou

Demonstra√ß√£o com continue:
  Processando 1
  Processando 2
  Encontrei 3, pulando com continue
  Processando 4
  Processando 5
La√ßo com continue terminou
</code></pre>
<hr />
<h2 id="5-controle-de-fluxo-em-la√ßos-aninhados">5. Controle de Fluxo em La√ßos Aninhados</h2>
<h3 id="5-1-code-break-code-e-code-continue-code-em-la√ßos-aninhados">5.1. <code>break</code> e <code>continue</code> em La√ßos Aninhados</h3>
<p>Por padr√£o, <code>break</code> e <code>continue</code> afetam apenas o la√ßo mais interno em que est√£o contidos.</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;La√ßos aninhados com break:&quot;)

    for i := 1; i &lt;= 3; i++ {
        fmt.Printf(&quot;La√ßo externo: i = %d\n&quot;, i)

        for j := 1; j &lt;= 3; j++ {
            if j == 2 {
                fmt.Println(&quot;  j = 2, usando break no la√ßo interno&quot;)
                break // Afeta apenas o la√ßo interno
            }

            fmt.Printf(&quot;  La√ßo interno: j = %d\n&quot;, j)
        }

        fmt.Println(&quot;  Fim da itera√ß√£o do la√ßo externo&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>La√ßos aninhados com break:
La√ßo externo: i = 1
  La√ßo interno: j = 1
  j = 2, usando break no la√ßo interno
  Fim da itera√ß√£o do la√ßo externo
La√ßo externo: i = 2
  La√ßo interno: j = 1
  j = 2, usando break no la√ßo interno
  Fim da itera√ß√£o do la√ßo externo
La√ßo externo: i = 3
  La√ßo interno: j = 1
  j = 2, usando break no la√ßo interno
  Fim da itera√ß√£o do la√ßo externo
</code></pre>
<p>Observe que o <code>break</code> sai apenas do la√ßo interno, e o la√ßo externo continua normalmente.</p>
<h3 id="5-2-usando-r√≥tulos-labels-para-controle-avan√ßado">5.2. Usando R√≥tulos (Labels) para Controle Avan√ßado</h3>
<p>Em Go, podemos usar r√≥tulos (labels) para especificar qual la√ßo queremos afetar com <code>break</code> ou <code>continue</code>.</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Usando r√≥tulos com break:&quot;)

ExternoLoop:
    for i := 1; i &lt;= 3; i++ {
        fmt.Printf(&quot;La√ßo externo: i = %d\n&quot;, i)

        for j := 1; j &lt;= 3; j++ {
            if i == 2 &amp;&amp; j == 2 {
                fmt.Println(&quot;  i = 2, j = 2, usando break para sair do la√ßo externo&quot;)
                break ExternoLoop // Sai do la√ßo rotulado como ExternoLoop
            }

            fmt.Printf(&quot;  La√ßo interno: j = %d\n&quot;, j)
        }

        fmt.Println(&quot;  Fim da itera√ß√£o do la√ßo externo&quot;)
    }

    fmt.Println(&quot;Programa conclu√≠do&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Usando r√≥tulos com break:
La√ßo externo: i = 1
  La√ßo interno: j = 1
  La√ßo interno: j = 2
  La√ßo interno: j = 3
  Fim da itera√ß√£o do la√ßo externo
La√ßo externo: i = 2
  La√ßo interno: j = 1
  i = 2, j = 2, usando break para sair do la√ßo externo
Programa conclu√≠do
</code></pre>
<p>Neste exemplo, quando <code>i == 2</code> e <code>j == 2</code>, usamos <code>break ExternoLoop</code> para sair completamente do la√ßo externo, n√£o apenas do la√ßo interno.</p>
<h3 id="5-3-exemplo-pr√°tico-busca-em-matriz">5.3. Exemplo Pr√°tico: Busca em Matriz</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Matriz 3x3
    matriz := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    valorProcurado := 5
    encontrado := false
    var linha, coluna int

BuscaLoop:
    for i := 0; i &lt; len(matriz); i++ {
        for j := 0; j &lt; len(matriz[i]); j++ {
            if matriz[i][j] == valorProcurado {
                linha = i
                coluna = j
                encontrado = true
                break BuscaLoop
            }
        }
    }

    if encontrado {
        fmt.Printf(&quot;Valor %d encontrado na posi√ß√£o [%d][%d]\n&quot;, valorProcurado, linha, coluna)
    } else {
        fmt.Printf(&quot;Valor %d n√£o encontrado na matriz\n&quot;, valorProcurado)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Valor 5 encontrado na posi√ß√£o [1][1]
</code></pre>
<p>Neste exemplo, usamos um r√≥tulo e <code>break</code> para sair de ambos os la√ßos assim que encontramos o valor procurado.</p>
<hr />
<h2 id="6-aplica√ß√µes-pr√°ticas">6. Aplica√ß√µes Pr√°ticas</h2>
<h3 id="6-1-valida√ß√£o-de-entrada-com-code-break-code">6.1. Valida√ß√£o de Entrada com <code>break</code></h3>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var senha string

    for {
        fmt.Print(&quot;Digite uma senha (m√≠nimo 8 caracteres, pelo menos 1 n√∫mero): &quot;)
        fmt.Scanln(&amp;senha)

        // Verifica o comprimento
        if len(senha) &lt; 8 {
            fmt.Println(&quot;Erro: A senha deve ter pelo menos 8 caracteres&quot;)
            continue
        }

        // Verifica se cont√©m pelo menos um n√∫mero
        contemNumero := false
        for _, char := range senha {
            if strings.ContainsRune(&quot;0123456789&quot;, char) {
                contemNumero = true
                break
            }
        }

        if !contemNumero {
            fmt.Println(&quot;Erro: A senha deve conter pelo menos um n√∫mero&quot;)
            continue
        }

        // Se chegou aqui, a senha √© v√°lida
        fmt.Println(&quot;Senha v√°lida!&quot;)
        break
    }

    fmt.Println(&quot;Cadastro conclu√≠do&quot;)
}
</code></pre>
<p>Este exemplo usa <code>continue</code> para pular para a pr√≥xima itera√ß√£o quando a senha n√£o atende aos crit√©rios e <code>break</code> para sair do la√ßo quando a senha √© v√°lida.</p>
<h3 id="6-2-processamento-de-lista-com-code-continue-code">6.2. Processamento de Lista com <code>continue</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    numeros := []int{1, -2, 3, 0, -4, 5, 6, -7, 8, 9, 10}
    soma := 0
    contador := 0

    fmt.Println(&quot;Calculando a m√©dia dos n√∫meros positivos:&quot;)

    for _, num := range numeros {
        // Pula n√∫meros negativos e zero
        if num &lt;= 0 {
            fmt.Printf(&quot;  Pulando %d (n√£o √© positivo)\n&quot;, num)
            continue
        }

        soma += num
        contador++
        fmt.Printf(&quot;  Adicionando %d: soma = %d, contador = %d\n&quot;, num, soma, contador)
    }

    if contador &gt; 0 {
        media := float64(soma) / float64(contador)
        fmt.Printf(&quot;M√©dia dos n√∫meros positivos: %.2f\n&quot;, media)
    } else {
        fmt.Println(&quot;Nenhum n√∫mero positivo encontrado&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Calculando a m√©dia dos n√∫meros positivos:
  Adicionando 1: soma = 1, contador = 1
  Pulando -2 (n√£o √© positivo)
  Adicionando 3: soma = 4, contador = 2
  Pulando 0 (n√£o √© positivo)
  Pulando -4 (n√£o √© positivo)
  Adicionando 5: soma = 9, contador = 3
  Adicionando 6: soma = 15, contador = 4
  Pulando -7 (n√£o √© positivo)
  Adicionando 8: soma = 23, contador = 5
  Adicionando 9: soma = 32, contador = 6
  Adicionando 10: soma = 42, contador = 7
M√©dia dos n√∫meros positivos: 6.00
</code></pre>
<p>Este exemplo usa <code>continue</code> para pular n√∫meros n√£o positivos ao calcular a m√©dia.</p>
<h3 id="6-3-busca-eficiente-com-code-break-code">6.3. Busca Eficiente com <code>break</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Lista ordenada de n√∫meros
    numeros := []int{2, 5, 8, 12, 16, 23, 38, 56, 72, 91}

    // Valor a ser procurado
    alvo := 23

    // Busca linear
    encontrado := false
    posicao := -1

    for i, num := range numeros {
        fmt.Printf(&quot;Verificando posi√ß√£o %d: valor %d\n&quot;, i, num)

        if num == alvo {
            encontrado = true
            posicao = i
            break // Sai do la√ßo assim que encontra o valor
        }

        // Se a lista estiver ordenada, podemos otimizar ainda mais
        if num &gt; alvo {
            fmt.Printf(&quot;O valor %d √© maior que o alvo %d, n√£o precisa continuar a busca\n&quot;, num, alvo)
            break // Sai do la√ßo se o valor atual for maior que o alvo (lista ordenada)
        }
    }

    if encontrado {
        fmt.Printf(&quot;Valor %d encontrado na posi√ß√£o %d\n&quot;, alvo, posicao)
    } else {
        fmt.Printf(&quot;Valor %d n√£o encontrado na lista\n&quot;, alvo)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Verificando posi√ß√£o 0: valor 2
Verificando posi√ß√£o 1: valor 5
Verificando posi√ß√£o 2: valor 8
Verificando posi√ß√£o 3: valor 12
Verificando posi√ß√£o 4: valor 16
Verificando posi√ß√£o 5: valor 23
Valor 23 encontrado na posi√ß√£o 5
</code></pre>
<p>Este exemplo usa <code>break</code> para sair do la√ßo assim que encontra o valor procurado, evitando verifica√ß√µes desnecess√°rias.</p>
<h3 id="6-4-processamento-de-texto-com-code-continue-code">6.4. Processamento de Texto com <code>continue</code></h3>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    texto := &quot;Go √© uma linguagem de programa√ß√£o concorrente e compilada, desenvolvida pelo Google.&quot;
    vogais := &quot;aeiouAEIOU&quot;

    fmt.Println(&quot;Contando consoantes no texto:&quot;)
    fmt.Println(texto)

    consoantes := 0

    for _, char := range texto {
        // Pula caracteres que n√£o s√£o letras
        if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z')) {
            continue
        }

        // Pula vogais
        if strings.ContainsRune(vogais, char) {
            continue
        }

        // Se chegou aqui, √© uma consoante
        consoantes++
    }

    fmt.Printf(&quot;O texto cont√©m %d consoantes\n&quot;, consoantes)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Contando consoantes no texto:
Go √© uma linguagem de programa√ß√£o concorrente e compilada, desenvolvida pelo Google.
O texto cont√©m 40 consoantes
</code></pre>
<p>Este exemplo usa <code>continue</code> para pular caracteres que n√£o s√£o letras e vogais, contando apenas as consoantes.</p>
<hr />
<h2 id="7-boas-pr√°ticas">7. Boas Pr√°ticas</h2>
<h3 id="7-1-use-code-break-code-e-code-continue-code-com-modera√ß√£o">7.1. Use <code>break</code> e <code>continue</code> com Modera√ß√£o</h3>
<p>Embora <code>break</code> e <code>continue</code> sejam ferramentas poderosas, o uso excessivo pode tornar o c√≥digo dif√≠cil de entender e manter. Use-os quando realmente melhorarem a clareza ou efici√™ncia do c√≥digo.</p>
<h3 id="7-2-prefira-condi√ß√µes-claras">7.2. Prefira Condi√ß√µes Claras</h3>
<p>Em vez de usar <code>break</code> ou <code>continue</code> com condi√ß√µes complexas, considere refatorar o c√≥digo para usar condi√ß√µes mais claras:</p>
<pre><code class="language-go">// Menos claro
for i := 0; i &lt; len(items); i++ {
    if i &lt; 5 || items[i].IsSpecial() || processedCount &gt; 10 {
        continue
    }
    // Processamento
}

// Mais claro
for i := 0; i &lt; len(items); i++ {
    shouldSkip := i &lt; 5 || items[i].IsSpecial() || processedCount &gt; 10
    if shouldSkip {
        continue
    }
    // Processamento
}
</code></pre>
<h3 id="7-3-evite-la√ßos-aninhados-profundos-com-r√≥tulos">7.3. Evite La√ßos Aninhados Profundos com R√≥tulos</h3>
<p>Embora os r√≥tulos sejam √∫teis, la√ßos aninhados muito profundos com m√∫ltiplos <code>break</code> e <code>continue</code> rotulados podem tornar o c√≥digo dif√≠cil de entender. Considere refatorar o c√≥digo em fun√ß√µes separadas.</p>
<h3 id="7-4-documente-o-prop√≥sito">7.4. Documente o Prop√≥sito</h3>
<p>Quando usar <code>break</code> ou <code>continue</code> em situa√ß√µes n√£o triviais, adicione um coment√°rio explicando o prop√≥sito:</p>
<pre><code class="language-go">for _, item := range items {
    // Pula itens inv√°lidos para evitar processamento desnecess√°rio
    if !item.IsValid() {
        continue
    }

    // Processamento
}
</code></pre>
<h3 id="7-5-considere-alternativas">7.5. Considere Alternativas</h3>
<p>Em alguns casos, h√° alternativas mais claras ao uso de <code>break</code> e <code>continue</code>:</p>
<ul>
<li>Use fun√ß√µes com retorno antecipado em vez de la√ßos com m√∫ltiplos <code>break</code></li>
<li>Use filtros antes do la√ßo em vez de <code>continue</code> para pular itens</li>
<li>Use condi√ß√µes compostas em vez de m√∫ltiplos <code>if</code> com <code>continue</code></li>
</ul>
<hr />
<h2 id="8-exerc√≠cios-offline">8. Exerc√≠cios Offline</h2>
<ol>
<li>
<p><strong>N√∫meros Primos</strong>: Escreva um algoritmo que encontre os primeiros 10 n√∫meros primos. Use <code>break</code> para sair do la√ßo de verifica√ß√£o assim que encontrar um divisor.</p>
</li>
<li>
<p><strong>Filtro de Palavras</strong>: Crie um algoritmo que processe uma lista de palavras, ignorando aquelas com menos de 3 letras. Use <code>continue</code> para pular palavras curtas.</p>
</li>
<li>
<p><strong>Jogo de Adivinha√ß√£o</strong>: Desenvolva um algoritmo para um jogo onde o jogador tenta adivinhar um n√∫mero. Use <code>break</code> para sair quando o jogador acertar ou atingir o n√∫mero m√°ximo de tentativas.</p>
</li>
<li>
<p><strong>Processamento de Matriz</strong>: Crie um algoritmo que procure um valor espec√≠fico em uma matriz. Use r√≥tulos e <code>break</code> para sair de ambos os la√ßos quando encontrar o valor.</p>
</li>
<li>
<p><strong>Valida√ß√£o de Formul√°rio</strong>: Desenvolva um algoritmo que valide v√°rios campos de um formul√°rio. Use <code>continue</code> para pular para o pr√≥ximo campo quando o atual for v√°lido.</p>
</li>
</ol>
<hr />
<h2 id="9-quiz-r√°pido">9. Quiz R√°pido</h2>
<ol>
<li>
<p>O que a instru√ß√£o <code>break</code> faz em um la√ßo?
   a) Pula para a pr√≥xima itera√ß√£o
   b) Sai completamente do la√ßo
   c) Pausa o la√ßo temporariamente
   d) Reinicia o la√ßo do in√≠cio</p>
</li>
<li>
<p>O que a instru√ß√£o <code>continue</code> faz em um la√ßo?
   a) Sai completamente do la√ßo
   b) Pula para a pr√≥xima itera√ß√£o
   c) Pausa o la√ßo temporariamente
   d) Repete a itera√ß√£o atual</p>
</li>
<li>
<p>Em la√ßos aninhados, o que acontece quando usamos <code>break</code> sem r√≥tulo?
   a) Sai de todos os la√ßos aninhados
   b) Sai apenas do la√ßo mais interno
   c) Sai apenas do la√ßo mais externo
   d) Causa um erro de compila√ß√£o</p>
</li>
<li>
<p>Como podemos usar <code>break</code> para sair de um la√ßo externo em la√ßos aninhados?
   a) Usando uma vari√°vel de controle
   b) Usando <code>break 2</code>
   c) Usando um r√≥tulo (label)
   d) N√£o √© poss√≠vel em Go</p>
</li>
<li>
<p>Qual √© a principal diferen√ßa entre <code>break</code> e <code>continue</code>?
   a) <code>break</code> funciona apenas em <code>switch</code>, enquanto <code>continue</code> funciona apenas em la√ßos
   b) <code>break</code> sai do la√ßo, enquanto <code>continue</code> pula para a pr√≥xima itera√ß√£o
   c) <code>break</code> pode ser usado com r√≥tulos, mas <code>continue</code> n√£o
   d) <code>break</code> afeta apenas o la√ßo interno, enquanto <code>continue</code> afeta todos os la√ßos</p>
</li>
</ol>
<hr />
<h2 id="10-desafio-pr√°tico-processador-de-texto">10. Desafio Pr√°tico: Processador de Texto</h2>
<p>Crie um programa em Go que analise um texto e forne√ßa estat√≠sticas sobre ele. O programa deve:</p>
<ol>
<li>Contar o n√∫mero total de palavras no texto</li>
<li>Contar o n√∫mero de palavras com mais de 5 letras</li>
<li>Identificar a palavra mais longa</li>
<li>Contar a frequ√™ncia das 5 palavras mais comuns</li>
<li>Ignorar pontua√ß√£o e considerar mai√∫sculas e min√∫sculas como iguais</li>
</ol>
<p>Use <code>continue</code> para pular caracteres de pontua√ß√£o e <code>break</code> para otimizar a busca quando necess√°rio.</p>
<p><strong>Exemplo de Entrada:</strong></p>
<pre><code>Go √© uma linguagem de programa√ß√£o concorrente e compilada, desenvolvida pelo Google. √â uma linguagem de programa√ß√£o compilada e estaticamente tipada. Go foi criada para ser eficiente em termos de processamento, mem√≥ria e simplicidade de c√≥digo.
</code></pre>
<p><strong>Exemplo de Sa√≠da Esperada:</strong></p>
<pre><code>Estat√≠sticas do Texto:
---------------------
Total de palavras: 32
Palavras com mais de 5 letras: 14
Palavra mais longa: &quot;estaticamente&quot; (13 letras)

Top 5 palavras mais frequentes:
1. &quot;de&quot; (4 vezes)
2. &quot;e&quot; (3 vezes)
3. &quot;go&quot; (3 vezes)
4. &quot;programa√ß√£o&quot; (2 vezes)
5. &quot;linguagem&quot; (2 vezes)
</code></pre>
<p><strong>Dica:</strong> Use <code>strings.Fields()</code> para dividir o texto em palavras e <code>strings.ToLower()</code> para converter para min√∫sculas.</p>
<hr />
<h2 id="11-resumo-da-aula">11. Resumo da Aula</h2>
<p>Nesta aula, aprendemos sobre:</p>
<ul>
<li><strong>Instru√ß√£o <code>break</code></strong>: Usada para sair completamente de um la√ßo antes que sua condi√ß√£o normal de t√©rmino seja atingida.</li>
<li><strong>Instru√ß√£o <code>continue</code></strong>: Usada para pular o restante do c√≥digo na itera√ß√£o atual e avan√ßar para a pr√≥xima itera√ß√£o.</li>
<li><strong>La√ßos Aninhados</strong>: Por padr√£o, <code>break</code> e <code>continue</code> afetam apenas o la√ßo mais interno.</li>
<li><strong>R√≥tulos (Labels)</strong>: Permitem especificar qual la√ßo queremos afetar com <code>break</code> ou <code>continue</code> em la√ßos aninhados.</li>
<li><strong>Aplica√ß√µes Pr√°ticas</strong>: Valida√ß√£o de entrada, processamento de listas, busca eficiente e processamento de texto.</li>
<li><strong>Boas Pr√°ticas</strong>: Usar com modera√ß√£o, preferir condi√ß√µes claras, evitar la√ßos aninhados profundos com r√≥tulos e documentar o prop√≥sito.</li>
</ul>
<p>O controle de fluxo em la√ßos com <code>break</code> e <code>continue</code> √© uma ferramenta poderosa que, quando usada adequadamente, pode tornar seu c√≥digo mais eficiente e leg√≠vel.</p>
<hr />
<h2 id="12-ficha-de-refer√™ncia-r√°pida">12. Ficha de Refer√™ncia R√°pida</h2>
<h3 id="instru√ß√µes-de-controle-de-fluxo">Instru√ß√µes de Controle de Fluxo</h3>
<table>
<thead>
<tr>
<th>Instru√ß√£o</th>
<th>Sintaxe</th>
<th>Efeito</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td><code>break</code></td>
<td>Sai completamente do la√ßo</td>
</tr>
<tr>
<td><code>continue</code></td>
<td><code>continue</code></td>
<td>Pula para a pr√≥xima itera√ß√£o</td>
</tr>
<tr>
<td><code>break</code> com r√≥tulo</td>
<td><code>break rotulo</code></td>
<td>Sai do la√ßo rotulado</td>
</tr>
<tr>
<td><code>continue</code> com r√≥tulo</td>
<td><code>continue rotulo</code></td>
<td>Pula para a pr√≥xima itera√ß√£o do la√ßo rotulado</td>
</tr>
</tbody>
</table>
<h3 id="casos-de-uso-comuns">Casos de Uso Comuns</h3>
<table>
<thead>
<tr>
<th>Instru√ß√£o</th>
<th>Casos de Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td>Busca (sair quando encontrar), valida√ß√£o (sair quando v√°lido), menus (sair quando escolher sair)</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>Filtragem (pular itens inv√°lidos), tratamento de casos especiais, otimiza√ß√£o (pular processamento desnecess√°rio)</td>
</tr>
</tbody>
</table>
<h3 id="padr√µes-comuns">Padr√µes Comuns</h3>
<table>
<thead>
<tr>
<th>Padr√£o</th>
<th>C√≥digo</th>
</tr>
</thead>
<tbody>
<tr>
<td>Busca em cole√ß√£o</td>
<td><code>for _, item := range items { if item == target { found = true; break } }</code></td>
</tr>
<tr>
<td>Filtragem</td>
<td><code>for _, item := range items { if !isValid(item) { continue } process(item) }</code></td>
</tr>
<tr>
<td>Valida√ß√£o de entrada</td>
<td><code>for { input := getInput(); if isValid(input) { break } showError() }</code></td>
</tr>
<tr>
<td>Busca em matriz</td>
<td><code>outer: for i := range matrix { for j := range matrix[i] { if matrix[i][j] == target { break outer } } }</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="13-modelos-de-c√≥digo">13. Modelos de C√≥digo</h2>
<h3 id="modelo-1-busca-com-code-break-code">Modelo 1: Busca com <code>break</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Lista de itens para busca
    itens := []string{&quot;ma√ß√£&quot;, &quot;banana&quot;, &quot;laranja&quot;, &quot;uva&quot;, &quot;pera&quot;}
    alvo := &quot;laranja&quot;

    // Inicializa vari√°veis
    encontrado := false
    posicao := -1

    // Busca o item na lista
    for i, item := range itens {
        if item == alvo {
            encontrado = true
            posicao = i
            break // Sai do la√ßo assim que encontra o item
        }
    }

    // Exibe o resultado
    if encontrado {
        fmt.Printf(&quot;Item '%s' encontrado na posi√ß√£o %d\n&quot;, alvo, posicao)
    } else {
        fmt.Printf(&quot;Item '%s' n√£o encontrado na lista\n&quot;, alvo)
    }
}
</code></pre>
<h3 id="modelo-2-filtragem-com-code-continue-code">Modelo 2: Filtragem com <code>continue</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Lista de n√∫meros
    numeros := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    fmt.Println(&quot;N√∫meros √≠mpares:&quot;)

    // Filtra e processa apenas os n√∫meros √≠mpares
    for _, num := range numeros {
        // Pula os n√∫meros pares
        if num%2 == 0 {
            continue
        }

        // Processa apenas os n√∫meros √≠mpares
        fmt.Printf(&quot;%d ao quadrado = %d\n&quot;, num, num*num)
    }
}
</code></pre>
<h3 id="modelo-3-valida√ß√£o-de-entrada-com-code-break-code">Modelo 3: Valida√ß√£o de Entrada com <code>break</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var idade int

    // Loop at√© receber uma idade v√°lida
    for {
        fmt.Print(&quot;Digite sua idade (entre 0 e 120): &quot;)
        fmt.Scanln(&amp;idade)

        // Verifica se a idade √© v√°lida
        if idade &gt;= 0 &amp;&amp; idade &lt;= 120 {
            break // Sai do la√ßo se a idade for v√°lida
        }

        fmt.Println(&quot;Idade inv√°lida! Por favor, tente novamente.&quot;)
    }

    fmt.Printf(&quot;Idade v√°lida: %d anos\n&quot;, idade)
}
</code></pre>
<h3 id="modelo-4-la√ßos-aninhados-com-r√≥tulos">Modelo 4: La√ßos Aninhados com R√≥tulos</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Matriz 3x3
    matriz := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    // Busca um valor espec√≠fico na matriz
    valorAlvo := 5
    encontrado := false

ExternoLoop:
    for i := 0; i &lt; len(matriz); i++ {
        for j := 0; j &lt; len(matriz[i]); j++ {
            fmt.Printf(&quot;Verificando posi√ß√£o [%d][%d]: %d\n&quot;, i, j, matriz[i][j])

            if matriz[i][j] == valorAlvo {
                fmt.Printf(&quot;Valor %d encontrado na posi√ß√£o [%d][%d]\n&quot;, valorAlvo, i, j)
                encontrado = true
                break ExternoLoop // Sai de ambos os la√ßos
            }
        }
    }

    if !encontrado {
        fmt.Printf(&quot;Valor %d n√£o encontrado na matriz\n&quot;, valorAlvo)
    }
}
</code></pre>
<hr />
<p><strong>Gabarito do Quiz:</strong>
1. b) Sai completamente do la√ßo
2. b) Pula para a pr√≥xima itera√ß√£o
3. b) Sai apenas do la√ßo mais interno
4. c) Usando um r√≥tulo (label)
5. b) <code>break</code> sai do la√ßo, enquanto <code>continue</code> pula para a pr√≥xima itera√ß√£o</p>
  </article>
</main>

</body>
</html>