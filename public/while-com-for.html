<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aula 9: While com For</title>
  <link rel="stylesheet" href="themes/rustbook/css/water-dark.css">
  <link rel="stylesheet" href="themes/rustbook/css/theme.css">
  <script src="themes/rustbook/js/theme.js" defer></script>
</head>
<body>

<aside>
  <header><h1>Curso de Algoritmos com Go</h1></header>
  <nav aria-label="Conte√∫do do curso">
    <ul>
      <li><a href="index.html">üìö √çndice Geral</a></li>
      <li><a href="algoritmos-base.html">Aula 1: Algoritmos ‚Äì A Base de Tudo!</a></li>
      <li><a href="break-e-continue.html">Aula 10: Break e Continue</a></li>
      <li><a href="condicional-if-else.html">Aula 6: Condicional If/Else</a></li>
      <li><a href="condicional-switch.html">Aula 7: Condicional Switch</a></li>
      <li><a href="entrada-e-saida.html">Aula 4: Entrada e Sa√≠da com Go</a></li>
      <li><a href="estrutura-sequencial.html">Aula 5: Estrutura Sequencial</a></li>
      <li><a href="identificadores-operadores.html">Aula 3: Identificadores e Operadores</a></li>
      <li><a href="nova_aula.html">Nova aula</a></li>
      <li><a href="repeticao-for.html">Aula 8: Repeti√ß√£o com For</a></li>
      <li><a href="variaveis-e-tipos.html">Aula 2: Vari√°veis e Tipos de Dados em Go</a></li>
      <li><a href="while-com-for.html">Aula 9: While com For</a></li>
    </ul>
  </nav>
</aside>

<main>
  <article>
    <h2>Aula 9: While com For</h2>
    <nav class="minimap"><ul><li class="lvl2"><a href="#objetivos-da-aula">Objetivos da Aula</a></li><li class="lvl2"><a href="#1-introdu√ß√£o-aos-la√ßos-com-condi√ß√£o">1. Introdu√ß√£o aos La√ßos com Condi√ß√£o</a></li><li class="lvl3"><a href="#1-1-o-que-s√£o-la√ßos-com-condi√ß√£o">1.1. O que s√£o La√ßos com Condi√ß√£o?</a></li><li class="lvl3"><a href="#1-2-la√ßos-com-condi√ß√£o-vs-la√ßos-com-contador">1.2. La√ßos com Condi√ß√£o vs. La√ßos com Contador</a></li><li class="lvl3"><a href="#1-3-quando-usar-la√ßos-com-condi√ß√£o">1.3. Quando Usar La√ßos com Condi√ß√£o?</a></li><li class="lvl2"><a href="#2-implementando-la√ßos-condicionais-em-go">2. Implementando La√ßos Condicionais em Go</a></li><li class="lvl3"><a href="#2-1-sintaxe-do-code-for-code-como-code-while-code">2.1. Sintaxe do <code>for</code> como <code>while</code></a></li><li class="lvl3"><a href="#2-2-fluxo-de-execu√ß√£o-do-la√ßo-condicional">2.2. Fluxo de Execu√ß√£o do La√ßo Condicional</a></li><li class="lvl3"><a href="#2-3-diferen√ßas-importantes-em-rela√ß√£o-ao-code-for-code-cl√°ssico">2.3. Diferen√ßas Importantes em Rela√ß√£o ao <code>for</code> Cl√°ssico</a></li><li class="lvl3"><a href="#2-4-simulando-o-code-do-while-code">2.4. Simulando o <code>do-while</code></a></li><li class="lvl2"><a href="#3-la√ßos-infinitos-e-controle-de-fluxo">3. La√ßos Infinitos e Controle de Fluxo</a></li><li class="lvl3"><a href="#3-1-la√ßos-infinitos">3.1. La√ßos Infinitos</a></li><li class="lvl3"><a href="#3-2-usando-code-break-code-para-sair-do-loop">3.2. Usando <code>break</code> para Sair do Loop</a></li><li class="lvl3"><a href="#3-3-usando-code-continue-code-para-pular-itera√ß√µes">3.3. Usando <code>continue</code> para Pular Itera√ß√µes</a></li><li class="lvl3"><a href="#3-4-la√ßos-com-condi√ß√£o-de-sa√≠da-no-meio">3.4. La√ßos com Condi√ß√£o de Sa√≠da no Meio</a></li><li class="lvl2"><a href="#4-aplica√ß√µes-pr√°ticas-de-la√ßos-condicionais">4. Aplica√ß√µes Pr√°ticas de La√ßos Condicionais</a></li><li class="lvl3"><a href="#4-1-valida√ß√£o-de-entrada">4.1. Valida√ß√£o de Entrada</a></li><li class="lvl3"><a href="#4-2-processamento-de-dados-at√©-uma-condi√ß√£o">4.2. Processamento de Dados at√© uma Condi√ß√£o</a></li><li class="lvl3"><a href="#4-3-algoritmo-de-busca">4.3. Algoritmo de Busca</a></li><li class="lvl3"><a href="#4-4-algoritmo-de-adivinha√ß√£o">4.4. Algoritmo de Adivinha√ß√£o</a></li><li class="lvl2"><a href="#5-boas-pr√°ticas-com-la√ßos-condicionais">5. Boas Pr√°ticas com La√ßos Condicionais</a></li><li class="lvl3"><a href="#5-1-evite-loops-infinitos-acidentais">5.1. Evite Loops Infinitos Acidentais</a></li><li class="lvl3"><a href="#5-2-prefira-condi√ß√µes-simples">5.2. Prefira Condi√ß√µes Simples</a></li><li class="lvl3"><a href="#5-3-inicialize-vari√°veis-antes-do-loop">5.3. Inicialize Vari√°veis Antes do Loop</a></li><li class="lvl3"><a href="#5-4-atualize-as-vari√°veis-de-controle-dentro-do-loop">5.4. Atualize as Vari√°veis de Controle Dentro do Loop</a></li><li class="lvl3"><a href="#5-5-use-code-break-code-e-code-continue-code-com-modera√ß√£o">5.5. Use <code>break</code> e <code>continue</code> com Modera√ß√£o</a></li><li class="lvl2"><a href="#6-exemplos-pr√°ticos">6. Exemplos Pr√°ticos</a></li><li class="lvl3"><a href="#6-1-calculadora-simples-com-loop">6.1. Calculadora Simples com Loop</a></li><li class="lvl3"><a href="#6-2-encontrando-o-m√°ximo-divisor-comum-mdc">6.2. Encontrando o M√°ximo Divisor Comum (MDC)</a></li><li class="lvl3"><a href="#6-3-verifica√ß√£o-de-n√∫mero-perfeito">6.3. Verifica√ß√£o de N√∫mero Perfeito</a></li><li class="lvl3"><a href="#6-4-convers√£o-de-decimal-para-bin√°rio">6.4. Convers√£o de Decimal para Bin√°rio</a></li><li class="lvl2"><a href="#7-exerc√≠cios-offline">7. Exerc√≠cios Offline</a></li><li class="lvl2"><a href="#8-quiz-r√°pido">8. Quiz R√°pido</a></li><li class="lvl2"><a href="#9-desafio-pr√°tico-sistema-de-menu-interativo">9. Desafio Pr√°tico: Sistema de Menu Interativo</a></li><li class="lvl2"><a href="#10-resumo-da-aula">10. Resumo da Aula</a></li><li class="lvl2"><a href="#11-ficha-de-refer√™ncia-r√°pida">11. Ficha de Refer√™ncia R√°pida</a></li><li class="lvl3"><a href="#la√ßos-condicionais-em-go">La√ßos Condicionais em Go</a></li><li class="lvl3"><a href="#instru√ß√µes-de-controle-de-fluxo">Instru√ß√µes de Controle de Fluxo</a></li><li class="lvl3"><a href="#padr√µes-comuns">Padr√µes Comuns</a></li><li class="lvl3"><a href="#compara√ß√£o-la√ßos-com-contador-vs-la√ßos-com-condi√ß√£o">Compara√ß√£o: La√ßos com Contador vs. La√ßos com Condi√ß√£o</a></li><li class="lvl2"><a href="#12-modelos-de-c√≥digo">12. Modelos de C√≥digo</a></li><li class="lvl3"><a href="#modelo-1-la√ßo-condicional-b√°sico">Modelo 1: La√ßo Condicional B√°sico</a></li><li class="lvl3"><a href="#modelo-2-valida√ß√£o-de-entrada">Modelo 2: Valida√ß√£o de Entrada</a></li><li class="lvl3"><a href="#modelo-3-processamento-at√©-condi√ß√£o">Modelo 3: Processamento at√© Condi√ß√£o</a></li><li class="lvl3"><a href="#modelo-4-simula√ß√£o-de-do-while">Modelo 4: Simula√ß√£o de Do-While</a></li></ul></nav><h1>Aula 9: La√ßos com Condi√ß√£o em Go (Simula√ß√£o de <code>while</code>)</h1>
<h2 id="objetivos-da-aula">Objetivos da Aula</h2>
<p>Ao final desta aula, voc√™ ser√° capaz de:</p>
<ul>
<li>Compreender como implementar la√ßos baseados em condi√ß√£o em Go</li>
<li>Utilizar a estrutura <code>for</code> com apenas condi√ß√£o para simular o comportamento de <code>while</code></li>
<li>Implementar diferentes padr√µes de la√ßos condicionais para resolver problemas</li>
<li>Entender as diferen√ßas entre la√ßos com contador e la√ßos com condi√ß√£o</li>
<li>Criar programas em Go que utilizam la√ßos condicionais para processar dados de forma din√¢mica</li>
</ul>
<hr />
<h2 id="1-introdu√ß√£o-aos-la√ßos-com-condi√ß√£o">1. Introdu√ß√£o aos La√ßos com Condi√ß√£o</h2>
<h3 id="1-1-o-que-s√£o-la√ßos-com-condi√ß√£o">1.1. O que s√£o La√ßos com Condi√ß√£o?</h3>
<p>Os <strong>la√ßos com condi√ß√£o</strong> s√£o estruturas de repeti√ß√£o que executam um bloco de c√≥digo enquanto uma determinada condi√ß√£o for verdadeira. Diferentemente dos la√ßos com contador, que executam um n√∫mero predefinido de vezes, os la√ßos com condi√ß√£o podem executar zero, uma ou v√°rias vezes, dependendo da condi√ß√£o avaliada.</p>
<p>Em muitas linguagens de programa√ß√£o, existem estruturas espec√≠ficas para la√ßos condicionais, como <code>while</code> e <code>do-while</code>. Em Go, no entanto, todas as estruturas de repeti√ß√£o s√£o implementadas usando a palavra-chave <code>for</code>, com diferentes sintaxes para cada caso.</p>
<h3 id="1-2-la√ßos-com-condi√ß√£o-vs-la√ßos-com-contador">1.2. La√ßos com Condi√ß√£o vs. La√ßos com Contador</h3>
<p>Vamos comparar os dois tipos de la√ßos:</p>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th>La√ßo com Contador</th>
<th>La√ßo com Condi√ß√£o</th>
</tr>
</thead>
<tbody>
<tr>
<td>N√∫mero de itera√ß√µes</td>
<td>Conhecido previamente</td>
<td>Pode variar dependendo da condi√ß√£o</td>
</tr>
<tr>
<td>Uso t√≠pico</td>
<td>Processar sequ√™ncias de tamanho conhecido</td>
<td>Processar dados at√© que uma condi√ß√£o seja atendida</td>
</tr>
<tr>
<td>Implementa√ß√£o em Go</td>
<td><code>for i := 0; i &lt; n; i++ { ... }</code></td>
<td><code>for condi√ß√£o { ... }</code></td>
</tr>
<tr>
<td>Exemplo de uso</td>
<td>Percorrer um array</td>
<td>Ler dados at√© encontrar um valor espec√≠fico</td>
</tr>
</tbody>
</table>
<h3 id="1-3-quando-usar-la√ßos-com-condi√ß√£o">1.3. Quando Usar La√ßos com Condi√ß√£o?</h3>
<p>Os la√ßos com condi√ß√£o s√£o ideais para situa√ß√µes em que:</p>
<ol>
<li>O n√∫mero de itera√ß√µes n√£o √© conhecido antecipadamente.</li>
<li>O loop deve continuar at√© que uma condi√ß√£o espec√≠fica seja atendida.</li>
<li>O loop pode precisar ser executado zero vezes (se a condi√ß√£o for falsa desde o in√≠cio).</li>
<li>Voc√™ est√° processando dados de entrada at√© encontrar um marcador de fim.</li>
</ol>
<p>Exemplos do cotidiano que se assemelham a la√ßos condicionais:
- Lavar pratos at√© que todos estejam limpos
- Estudar at√© compreender o assunto
- Procurar um item at√© encontr√°-lo
- Jogar um jogo at√© perder ou ganhar</p>
<hr />
<h2 id="2-implementando-la√ßos-condicionais-em-go">2. Implementando La√ßos Condicionais em Go</h2>
<h3 id="2-1-sintaxe-do-code-for-code-como-code-while-code">2.1. Sintaxe do <code>for</code> como <code>while</code></h3>
<p>Em Go, o la√ßo condicional √© implementado usando a estrutura <code>for</code> com apenas a condi√ß√£o:</p>
<pre><code class="language-go">for condi√ß√£o {
    // C√≥digo a ser repetido enquanto a condi√ß√£o for verdadeira
}
</code></pre>
<p>Esta sintaxe √© equivalente ao <code>while</code> em outras linguagens:</p>
<pre><code>// Pseudoc√≥digo em outras linguagens
while (condi√ß√£o) {
    // C√≥digo a ser repetido
}
</code></pre>
<p>Exemplo simples:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    contador := 1

    for contador &lt;= 5 {
        fmt.Println(contador)
        contador++
    }

    fmt.Println(&quot;Fim do loop&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>1
2
3
4
5
Fim do loop
</code></pre>
<p>Neste exemplo:
- A condi√ß√£o <code>contador &lt;= 5</code> √© verificada antes de cada itera√ß√£o.
- O bloco de c√≥digo √© executado enquanto a condi√ß√£o for verdadeira.
- O contador √© incrementado dentro do bloco.
- Quando o contador se torna 6, a condi√ß√£o se torna falsa e o loop termina.</p>
<h3 id="2-2-fluxo-de-execu√ß√£o-do-la√ßo-condicional">2.2. Fluxo de Execu√ß√£o do La√ßo Condicional</h3>
<p>Vamos analisar o fluxo de execu√ß√£o passo a passo:</p>
<ol>
<li>A <strong>condi√ß√£o</strong> √© verificada.</li>
<li>Se for verdadeira, o bloco de c√≥digo √© executado.</li>
<li>Se for falsa, o loop termina e o programa continua ap√≥s o bloco <code>for</code>.</li>
<li>Ap√≥s a execu√ß√£o do bloco, volta ao passo 1 (verifica√ß√£o da condi√ß√£o).</li>
</ol>
<p>Vamos visualizar o fluxo para o exemplo anterior:</p>
<pre><code>Condi√ß√£o: 1 &lt;= 5? Sim, ent√£o:
  Executa: fmt.Println(1)
  Executa: contador++ (contador = 2)
Condi√ß√£o: 2 &lt;= 5? Sim, ent√£o:
  Executa: fmt.Println(2)
  Executa: contador++ (contador = 3)
Condi√ß√£o: 3 &lt;= 5? Sim, ent√£o:
  Executa: fmt.Println(3)
  Executa: contador++ (contador = 4)
Condi√ß√£o: 4 &lt;= 5? Sim, ent√£o:
  Executa: fmt.Println(4)
  Executa: contador++ (contador = 5)
Condi√ß√£o: 5 &lt;= 5? Sim, ent√£o:
  Executa: fmt.Println(5)
  Executa: contador++ (contador = 6)
Condi√ß√£o: 6 &lt;= 5? N√£o, ent√£o sai do loop
Executa: fmt.Println(&quot;Fim do loop&quot;)
</code></pre>
<h3 id="2-3-diferen√ßas-importantes-em-rela√ß√£o-ao-code-for-code-cl√°ssico">2.3. Diferen√ßas Importantes em Rela√ß√£o ao <code>for</code> Cl√°ssico</h3>
<p>Ao usar o <code>for</code> como um la√ßo condicional, existem algumas diferen√ßas importantes em rela√ß√£o ao <code>for</code> cl√°ssico:</p>
<ol>
<li><strong>Inicializa√ß√£o</strong>: N√£o h√° uma se√ß√£o de inicializa√ß√£o. As vari√°veis devem ser inicializadas antes do loop.</li>
<li><strong>Incremento</strong>: N√£o h√° uma se√ß√£o de p√≥s-execu√ß√£o. O incremento ou atualiza√ß√£o das vari√°veis deve ser feito explicitamente dentro do bloco.</li>
<li><strong>Condi√ß√£o</strong>: A condi√ß√£o √© verificada antes de cada itera√ß√£o, assim como no <code>for</code> cl√°ssico.</li>
</ol>
<pre><code class="language-go">// for cl√°ssico
for i := 1; i &lt;= 5; i++ {
    fmt.Println(i)
}

// for como while
i := 1
for i &lt;= 5 {
    fmt.Println(i)
    i++
}
</code></pre>
<p>Ambos os c√≥digos produzem o mesmo resultado, mas a estrutura √© diferente.</p>
<h3 id="2-4-simulando-o-code-do-while-code">2.4. Simulando o <code>do-while</code></h3>
<p>Muitas linguagens t√™m uma estrutura chamada <code>do-while</code>, que executa o bloco pelo menos uma vez e depois verifica a condi√ß√£o. Go n√£o tem uma sintaxe espec√≠fica para isso, mas podemos simular esse comportamento:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    contador := 1

    // Simulando do-while
    for {
        fmt.Println(contador)
        contador++

        if contador &gt; 5 {
            break
        }
    }

    fmt.Println(&quot;Fim do loop&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>1
2
3
4
5
Fim do loop
</code></pre>
<p>Neste exemplo:
- Usamos um loop infinito (<code>for { ... }</code>) para garantir que o bloco seja executado pelo menos uma vez.
- Verificamos a condi√ß√£o ap√≥s a execu√ß√£o do bloco.
- Usamos <code>break</code> para sair do loop quando a condi√ß√£o n√£o for mais atendida.</p>
<hr />
<h2 id="3-la√ßos-infinitos-e-controle-de-fluxo">3. La√ßos Infinitos e Controle de Fluxo</h2>
<h3 id="3-1-la√ßos-infinitos">3.1. La√ßos Infinitos</h3>
<p>Um la√ßo infinito √© um loop que, teoricamente, nunca termina. Em Go, podemos criar um la√ßo infinito de duas maneiras:</p>
<pre><code class="language-go">// M√©todo 1: Usando for sem condi√ß√£o
for {
    // C√≥digo a ser repetido indefinidamente
}

// M√©todo 2: Usando uma condi√ß√£o que √© sempre verdadeira
for true {
    // C√≥digo a ser repetido indefinidamente
}
</code></pre>
<p>La√ßos infinitos s√£o √∫teis quando queremos que o programa continue executando at√© que uma condi√ß√£o espec√≠fica seja atendida, momento em que usamos <code>break</code> para sair do loop.</p>
<h3 id="3-2-usando-code-break-code-para-sair-do-loop">3.2. Usando <code>break</code> para Sair do Loop</h3>
<p>A instru√ß√£o <code>break</code> permite sair imediatamente de um loop, independentemente da condi√ß√£o:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    contador := 1

    for {
        fmt.Println(contador)
        contador++

        if contador &gt; 5 {
            fmt.Println(&quot;Saindo do loop com break&quot;)
            break
        }
    }

    fmt.Println(&quot;Fim do programa&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>1
2
3
4
5
Saindo do loop com break
Fim do programa
</code></pre>
<h3 id="3-3-usando-code-continue-code-para-pular-itera√ß√µes">3.3. Usando <code>continue</code> para Pular Itera√ß√µes</h3>
<p>A instru√ß√£o <code>continue</code> permite pular o restante do bloco e ir para a pr√≥xima itera√ß√£o:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    for i := 1; i &lt;= 10; i++ {
        // Pula os n√∫meros pares
        if i%2 == 0 {
            continue
        }

        fmt.Println(i)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>1
3
5
7
9
</code></pre>
<p>Neste exemplo, quando <code>i</code> √© par, a instru√ß√£o <code>continue</code> faz com que o loop pule para a pr√≥xima itera√ß√£o sem executar o <code>fmt.Println(i)</code>.</p>
<h3 id="3-4-la√ßos-com-condi√ß√£o-de-sa√≠da-no-meio">3.4. La√ßos com Condi√ß√£o de Sa√≠da no Meio</h3>
<p>Em alguns casos, queremos verificar uma condi√ß√£o no meio do loop. Podemos fazer isso combinando um la√ßo infinito com <code>break</code>:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    soma := 0

    for {
        soma += 10
        fmt.Println(&quot;Soma atual:&quot;, soma)

        // Condi√ß√£o de sa√≠da no meio do loop
        if soma &gt;= 50 {
            fmt.Println(&quot;Soma atingiu ou ultrapassou 50&quot;)
            break
        }

        fmt.Println(&quot;Continuando o loop...&quot;)
    }

    fmt.Println(&quot;Fim do programa&quot;)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Soma atual: 10
Continuando o loop...
Soma atual: 20
Continuando o loop...
Soma atual: 30
Continuando o loop...
Soma atual: 40
Continuando o loop...
Soma atual: 50
Soma atingiu ou ultrapassou 50
Fim do programa
</code></pre>
<hr />
<h2 id="4-aplica√ß√µes-pr√°ticas-de-la√ßos-condicionais">4. Aplica√ß√µes Pr√°ticas de La√ßos Condicionais</h2>
<h3 id="4-1-valida√ß√£o-de-entrada">4.1. Valida√ß√£o de Entrada</h3>
<p>Os la√ßos condicionais s√£o frequentemente usados para validar entradas do usu√°rio:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var idade int

    // Loop at√© que o usu√°rio forne√ßa uma idade v√°lida
    for {
        fmt.Print(&quot;Digite sua idade (entre 0 e 120): &quot;)
        fmt.Scanln(&amp;idade)

        if idade &gt;= 0 &amp;&amp; idade &lt;= 120 {
            break
        }

        fmt.Println(&quot;Idade inv√°lida! Por favor, tente novamente.&quot;)
    }

    fmt.Printf(&quot;Idade v√°lida: %d anos\n&quot;, idade)
}
</code></pre>
<p>Este programa continua pedindo a idade at√© que o usu√°rio forne√ßa um valor entre 0 e 120.</p>
<h3 id="4-2-processamento-de-dados-at√©-uma-condi√ß√£o">4.2. Processamento de Dados at√© uma Condi√ß√£o</h3>
<p>La√ßos condicionais s√£o √∫teis para processar dados at√© que uma condi√ß√£o espec√≠fica seja atendida:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    soma := 0
    contador := 0

    fmt.Println(&quot;Digite n√∫meros para calcular a m√©dia (digite -1 para encerrar):&quot;)

    for {
        var numero int
        fmt.Print(&quot;N√∫mero: &quot;)
        fmt.Scanln(&amp;numero)

        if numero == -1 {
            break
        }

        soma += numero
        contador++
    }

    if contador &gt; 0 {
        media := float64(soma) / float64(contador)
        fmt.Printf(&quot;M√©dia dos %d n√∫meros: %.2f\n&quot;, contador, media)
    } else {
        fmt.Println(&quot;Nenhum n√∫mero foi inserido.&quot;)
    }
}
</code></pre>
<p>Este programa calcula a m√©dia de n√∫meros inseridos pelo usu√°rio at√© que ele digite -1.</p>
<h3 id="4-3-algoritmo-de-busca">4.3. Algoritmo de Busca</h3>
<p>La√ßos condicionais s√£o ideais para algoritmos de busca:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Array de n√∫meros
    numeros := []int{15, 7, 42, 23, 56, 8, 91, 30}

    // N√∫mero a ser procurado
    alvo := 23

    // Inicializa o √≠ndice e um flag para indicar se o n√∫mero foi encontrado
    indice := 0
    encontrado := false

    // Busca o n√∫mero no array
    for indice &lt; len(numeros) {
        if numeros[indice] == alvo {
            encontrado = true
            break
        }
        indice++
    }

    // Exibe o resultado
    if encontrado {
        fmt.Printf(&quot;O n√∫mero %d foi encontrado na posi√ß√£o %d\n&quot;, alvo, indice)
    } else {
        fmt.Printf(&quot;O n√∫mero %d n√£o foi encontrado no array\n&quot;, alvo)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>O n√∫mero 23 foi encontrado na posi√ß√£o 3
</code></pre>
<h3 id="4-4-algoritmo-de-adivinha√ß√£o">4.4. Algoritmo de Adivinha√ß√£o</h3>
<p>La√ßos condicionais s√£o perfeitos para jogos de adivinha√ß√£o:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func main() {
    // Inicializa o gerador de n√∫meros aleat√≥rios
    rand.Seed(time.Now().UnixNano())

    // Gera um n√∫mero aleat√≥rio entre 1 e 100
    numeroSecreto := rand.Intn(100) + 1

    fmt.Println(&quot;Jogo de Adivinha√ß√£o&quot;)
    fmt.Println(&quot;Estou pensando em um n√∫mero entre 1 e 100.&quot;)

    tentativas := 0
    acertou := false

    for !acertou {
        tentativas++

        var palpite int
        fmt.Printf(&quot;\nTentativa %d: Digite seu palpite: &quot;, tentativas)
        fmt.Scanln(&amp;palpite)

        if palpite &lt; numeroSecreto {
            fmt.Println(&quot;Muito baixo! Tente um n√∫mero maior.&quot;)
        } else if palpite &gt; numeroSecreto {
            fmt.Println(&quot;Muito alto! Tente um n√∫mero menor.&quot;)
        } else {
            acertou = true
            fmt.Printf(&quot;Parab√©ns! Voc√™ acertou em %d tentativas.\n&quot;, tentativas)
        }

        // Limite de tentativas (opcional)
        if tentativas == 10 &amp;&amp; !acertou {
            fmt.Printf(&quot;Voc√™ atingiu o limite de tentativas. O n√∫mero secreto era %d.\n&quot;, numeroSecreto)
            break
        }
    }
}
</code></pre>
<p>Este jogo gera um n√∫mero aleat√≥rio e d√° ao jogador v√°rias tentativas para adivinhar, fornecendo dicas ap√≥s cada palpite.</p>
<hr />
<h2 id="5-boas-pr√°ticas-com-la√ßos-condicionais">5. Boas Pr√°ticas com La√ßos Condicionais</h2>
<h3 id="5-1-evite-loops-infinitos-acidentais">5.1. Evite Loops Infinitos Acidentais</h3>
<p>Certifique-se de que a condi√ß√£o eventualmente se tornar√° falsa ou que haja um <code>break</code> para sair do loop:</p>
<pre><code class="language-go">// Potencialmente perigoso: se a condi√ß√£o nunca se tornar falsa
for x &gt; 0 {
    // Se n√£o houver nada aqui que altere x, este ser√° um loop infinito
}

// Seguro: garante que o loop terminar√°
for x &gt; 0 {
    x--
    // Ou alguma outra l√≥gica que eventualmente torne x &lt;= 0
}
</code></pre>
<h3 id="5-2-prefira-condi√ß√µes-simples">5.2. Prefira Condi√ß√µes Simples</h3>
<p>Mantenha as condi√ß√µes do loop simples e claras:</p>
<pre><code class="language-go">// Menos claro
for i &lt; 10 &amp;&amp; j &gt; 0 &amp;&amp; !done {
    // C√≥digo
}

// Mais claro
for !done {
    if i &gt;= 10 || j &lt;= 0 {
        done = true
        continue
    }
    // C√≥digo
}
</code></pre>
<h3 id="5-3-inicialize-vari√°veis-antes-do-loop">5.3. Inicialize Vari√°veis Antes do Loop</h3>
<p>Sempre inicialize as vari√°veis que ser√£o usadas na condi√ß√£o do loop antes de entrar nele:</p>
<pre><code class="language-go">// Bom: vari√°vel inicializada antes do loop
contador := 1
for contador &lt;= 5 {
    // C√≥digo
    contador++
}

// Ruim: vari√°vel n√£o inicializada (causaria erro de compila√ß√£o)
// var contador int
// for contador &lt;= 5 { // contador n√£o foi inicializado
//     // C√≥digo
//     contador++
// }
</code></pre>
<h3 id="5-4-atualize-as-vari√°veis-de-controle-dentro-do-loop">5.4. Atualize as Vari√°veis de Controle Dentro do Loop</h3>
<p>Certifique-se de atualizar as vari√°veis usadas na condi√ß√£o dentro do loop para evitar loops infinitos:</p>
<pre><code class="language-go">// Bom: a vari√°vel de controle √© atualizada dentro do loop
i := 0
for i &lt; 10 {
    fmt.Println(i)
    i++ // Atualiza√ß√£o importante
}

// Ruim: a vari√°vel de controle n√£o √© atualizada (loop infinito)
// i := 0
// for i &lt; 10 {
//     fmt.Println(i)
//     // Faltou i++
// }
</code></pre>
<h3 id="5-5-use-code-break-code-e-code-continue-code-com-modera√ß√£o">5.5. Use <code>break</code> e <code>continue</code> com Modera√ß√£o</h3>
<p>Embora <code>break</code> e <code>continue</code> sejam √∫teis, o uso excessivo pode tornar o c√≥digo dif√≠cil de entender:</p>
<pre><code class="language-go">// Menos leg√≠vel: muitos break e continue
for i := 0; i &lt; 100; i++ {
    if i &lt; 10 {
        continue
    }
    if i % 2 == 0 {
        continue
    }
    if i &gt; 50 {
        break
    }
    fmt.Println(i)
}

// Mais leg√≠vel: condi√ß√£o clara
for i := 11; i &lt;= 50; i += 2 {
    fmt.Println(i)
}
</code></pre>
<hr />
<h2 id="6-exemplos-pr√°ticos">6. Exemplos Pr√°ticos</h2>
<h3 id="6-1-calculadora-simples-com-loop">6.1. Calculadora Simples com Loop</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var continuar string

    for {
        var num1, num2 float64
        var operador string

        fmt.Print(&quot;Digite o primeiro n√∫mero: &quot;)
        fmt.Scanln(&amp;num1)

        fmt.Print(&quot;Digite o segundo n√∫mero: &quot;)
        fmt.Scanln(&amp;num2)

        fmt.Print(&quot;Digite o operador (+, -, *, /): &quot;)
        fmt.Scanln(&amp;operador)

        switch operador {
        case &quot;+&quot;:
            fmt.Printf(&quot;%.2f + %.2f = %.2f\n&quot;, num1, num2, num1+num2)
        case &quot;-&quot;:
            fmt.Printf(&quot;%.2f - %.2f = %.2f\n&quot;, num1, num2, num1-num2)
        case &quot;*&quot;:
            fmt.Printf(&quot;%.2f * %.2f = %.2f\n&quot;, num1, num2, num1*num2)
        case &quot;/&quot;:
            if num2 == 0 {
                fmt.Println(&quot;Erro: Divis√£o por zero!&quot;)
            } else {
                fmt.Printf(&quot;%.2f / %.2f = %.2f\n&quot;, num1, num2, num1/num2)
            }
        default:
            fmt.Println(&quot;Operador inv√°lido!&quot;)
        }

        fmt.Print(&quot;Deseja continuar? (s/n): &quot;)
        fmt.Scanln(&amp;continuar)

        if continuar != &quot;s&quot; &amp;&amp; continuar != &quot;S&quot; {
            break
        }
    }

    fmt.Println(&quot;Calculadora encerrada.&quot;)
}
</code></pre>
<p>Esta calculadora permite ao usu√°rio realizar v√°rias opera√ß√µes at√© decidir parar.</p>
<h3 id="6-2-encontrando-o-m√°ximo-divisor-comum-mdc">6.2. Encontrando o M√°ximo Divisor Comum (MDC)</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    a := 48
    b := 18

    fmt.Printf(&quot;Calculando o MDC de %d e %d\n&quot;, a, b)

    // Algoritmo de Euclides para MDC
    for b != 0 {
        a, b = b, a%b
    }

    fmt.Printf(&quot;MDC = %d\n&quot;, a)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Calculando o MDC de 48 e 18
MDC = 6
</code></pre>
<p>Este exemplo usa o algoritmo de Euclides para encontrar o m√°ximo divisor comum (MDC) de dois n√∫meros.</p>
<h3 id="6-3-verifica√ß√£o-de-n√∫mero-perfeito">6.3. Verifica√ß√£o de N√∫mero Perfeito</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    numero := 28
    soma := 0

    fmt.Printf(&quot;Verificando se %d √© um n√∫mero perfeito...\n&quot;, numero)

    // Um n√∫mero perfeito √© igual √† soma de seus divisores pr√≥prios
    for i := 1; i &lt; numero; i++ {
        if numero%i == 0 {
            soma += i
        }
    }

    if soma == numero {
        fmt.Printf(&quot;%d √© um n√∫mero perfeito!\n&quot;, numero)
    } else {
        fmt.Printf(&quot;%d n√£o √© um n√∫mero perfeito. A soma dos divisores √© %d.\n&quot;, numero, soma)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Verificando se 28 √© um n√∫mero perfeito...
28 √© um n√∫mero perfeito!
</code></pre>
<p>Um n√∫mero perfeito √© aquele que √© igual √† soma de seus divisores pr√≥prios (excluindo o pr√≥prio n√∫mero). Por exemplo, 28 = 1 + 2 + 4 + 7 + 14.</p>
<h3 id="6-4-convers√£o-de-decimal-para-bin√°rio">6.4. Convers√£o de Decimal para Bin√°rio</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    decimal := 42
    binario := &quot;&quot;

    fmt.Printf(&quot;Convertendo %d para bin√°rio...\n&quot;, decimal)

    // Caso especial para 0
    if decimal == 0 {
        binario = &quot;0&quot;
    }

    // Convers√£o para bin√°rio
    temp := decimal
    for temp &gt; 0 {
        resto := temp % 2
        binario = fmt.Sprintf(&quot;%d%s&quot;, resto, binario)
        temp = temp / 2
    }

    fmt.Printf(&quot;%d em bin√°rio √© %s\n&quot;, decimal, binario)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Convertendo 42 para bin√°rio...
42 em bin√°rio √© 101010
</code></pre>
<p>Este exemplo converte um n√∫mero decimal para sua representa√ß√£o bin√°ria.</p>
<hr />
<h2 id="7-exerc√≠cios-offline">7. Exerc√≠cios Offline</h2>
<ol>
<li>
<p><strong>Soma at√© Limite</strong>: Escreva um algoritmo que some n√∫meros inteiros consecutivos (1, 2, 3, ...) at√© que a soma ultrapasse um valor limite fornecido.</p>
</li>
<li>
<p><strong>Valida√ß√£o de Senha</strong>: Crie um algoritmo que pe√ßa ao usu√°rio para digitar uma senha e continue pedindo at√© que a senha correta seja fornecida.</p>
</li>
<li>
<p><strong>Contagem de D√≠gitos</strong>: Desenvolva um algoritmo que conte quantos d√≠gitos tem um n√∫mero inteiro positivo usando um la√ßo condicional.</p>
</li>
<li>
<p><strong>Jogo de Dados</strong>: Crie um algoritmo que simule lan√ßamentos de um dado at√© que o n√∫mero 6 apare√ßa.</p>
</li>
<li>
<p><strong>Sequ√™ncia de Collatz</strong>: Implemente o algoritmo da Conjectura de Collatz: comece com um n√∫mero n; se n for par, divida-o por 2; se for √≠mpar, multiplique por 3 e adicione 1. Repita o processo at√© que n se torne 1.</p>
</li>
</ol>
<hr />
<h2 id="8-quiz-r√°pido">8. Quiz R√°pido</h2>
<ol>
<li>
<p>Qual √© a sintaxe correta para um la√ßo condicional em Go?
   a) <code>while condi√ß√£o { c√≥digo }</code>
   b) <code>for (condi√ß√£o) { c√≥digo }</code>
   c) <code>for condi√ß√£o { c√≥digo }</code>
   d) <code>do { c√≥digo } while (condi√ß√£o)</code></p>
</li>
<li>
<p>O que acontece se a condi√ß√£o em um la√ßo condicional for falsa logo no in√≠cio?
   a) O loop executa pelo menos uma vez
   b) O loop n√£o executa nenhuma vez
   c) O programa gera um erro
   d) O loop executa infinitamente</p>
</li>
<li>
<p>Como podemos simular um <code>do-while</code> em Go?
   a) <code>do { c√≥digo } while (condi√ß√£o)</code>
   b) <code>for { c√≥digo; if (!condi√ß√£o) break; }</code>
   c) <code>for condi√ß√£o { c√≥digo }</code>
   d) N√£o √© poss√≠vel simular <code>do-while</code> em Go</p>
</li>
<li>
<p>O que faz a instru√ß√£o <code>continue</code> em um loop?
   a) Termina o loop completamente
   b) Pula para a pr√≥xima itera√ß√£o do loop
   c) Pausa o loop temporariamente
   d) Reinicia o loop do in√≠cio</p>
</li>
<li>
<p>Qual √© a principal diferen√ßa entre um la√ßo com contador e um la√ßo com condi√ß√£o?
   a) La√ßos com contador s√£o mais r√°pidos
   b) La√ßos com condi√ß√£o n√£o podem usar a instru√ß√£o <code>break</code>
   c) La√ßos com contador executam um n√∫mero predefinido de vezes
   d) La√ßos com condi√ß√£o s√≥ podem ser usados com n√∫meros</p>
</li>
</ol>
<hr />
<h2 id="9-desafio-pr√°tico-sistema-de-menu-interativo">9. Desafio Pr√°tico: Sistema de Menu Interativo</h2>
<p>Crie um programa em Go que simule um sistema de menu interativo para um caixa eletr√¥nico. O programa deve:</p>
<ol>
<li>Exibir um menu com op√ß√µes: 1. Ver Saldo, 2. Depositar, 3. Sacar, 4. Sair</li>
<li>Pedir ao usu√°rio para escolher uma op√ß√£o</li>
<li>Executar a opera√ß√£o correspondente</li>
<li>Voltar ao menu principal ap√≥s cada opera√ß√£o</li>
<li>Encerrar o programa apenas quando o usu√°rio escolher a op√ß√£o "Sair"</li>
</ol>
<p><strong>Exemplo de Sa√≠da Esperada:</strong></p>
<pre><code>=== CAIXA ELETR√îNICO ===

Saldo atual: R$ 1000.00

1. Ver Saldo
2. Depositar
3. Sacar
4. Sair

Escolha uma op√ß√£o: 2

Digite o valor do dep√≥sito: 500
Dep√≥sito de R$ 500.00 realizado com sucesso!

=== CAIXA ELETR√îNICO ===

Saldo atual: R$ 1500.00

1. Ver Saldo
2. Depositar
3. Sacar
4. Sair

Escolha uma op√ß√£o: 3

Digite o valor do saque: 200
Saque de R$ 200.00 realizado com sucesso!

=== CAIXA ELETR√îNICO ===

Saldo atual: R$ 1300.00

1. Ver Saldo
2. Depositar
3. Sacar
4. Sair

Escolha uma op√ß√£o: 4

Obrigado por utilizar nosso caixa eletr√¥nico!
</code></pre>
<p><strong>Dica:</strong> Use um la√ßo infinito (<code>for { ... }</code>) e saia dele apenas quando o usu√°rio escolher a op√ß√£o de sair.</p>
<hr />
<h2 id="10-resumo-da-aula">10. Resumo da Aula</h2>
<p>Nesta aula, aprendemos sobre:</p>
<ul>
<li><strong>La√ßos com Condi√ß√£o</strong>: Estruturas de repeti√ß√£o que executam um bloco de c√≥digo enquanto uma condi√ß√£o for verdadeira.</li>
<li><strong>Implementa√ß√£o em Go</strong>: Em Go, usamos <code>for condi√ß√£o { ... }</code> para simular o comportamento de <code>while</code> em outras linguagens.</li>
<li><strong>La√ßos Infinitos</strong>: Criados com <code>for { ... }</code> e geralmente combinados com <code>break</code> para sair quando uma condi√ß√£o espec√≠fica for atendida.</li>
<li><strong>Controle de Fluxo</strong>: Uso de <code>break</code> para sair do loop e <code>continue</code> para pular para a pr√≥xima itera√ß√£o.</li>
<li><strong>Simula√ß√£o de <code>do-while</code></strong>: Usando um la√ßo infinito com uma condi√ß√£o de sa√≠da no final do bloco.</li>
<li><strong>Aplica√ß√µes Pr√°ticas</strong>: Valida√ß√£o de entrada, processamento de dados, algoritmos de busca e jogos de adivinha√ß√£o.</li>
<li><strong>Boas Pr√°ticas</strong>: Evitar loops infinitos acidentais, preferir condi√ß√µes simples, inicializar vari√°veis antes do loop e atualizar vari√°veis de controle dentro do loop.</li>
</ul>
<p>Os la√ßos condicionais s√£o fundamentais para criar programas din√¢micos que podem responder a diferentes situa√ß√µes e processar dados de forma flex√≠vel.</p>
<hr />
<h2 id="11-ficha-de-refer√™ncia-r√°pida">11. Ficha de Refer√™ncia R√°pida</h2>
<h3 id="la√ßos-condicionais-em-go">La√ßos Condicionais em Go</h3>
<table>
<thead>
<tr>
<th>Tipo</th>
<th>Sintaxe</th>
<th>Equivalente em outras linguagens</th>
</tr>
</thead>
<tbody>
<tr>
<td>While</td>
<td><code>for condi√ß√£o { c√≥digo }</code></td>
<td><code>while (condi√ß√£o) { c√≥digo }</code></td>
</tr>
<tr>
<td>Do-While (simula√ß√£o)</td>
<td><code>for { c√≥digo; if (!condi√ß√£o) break; }</code></td>
<td><code>do { c√≥digo } while (condi√ß√£o);</code></td>
</tr>
<tr>
<td>Loop infinito</td>
<td><code>for { c√≥digo }</code></td>
<td><code>while (true) { c√≥digo }</code></td>
</tr>
</tbody>
</table>
<h3 id="instru√ß√µes-de-controle-de-fluxo">Instru√ß√µes de Controle de Fluxo</h3>
<table>
<thead>
<tr>
<th>Instru√ß√£o</th>
<th>Descri√ß√£o</th>
<th>Exemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td>Sai do loop imediatamente</td>
<td><code>if condi√ß√£o { break }</code></td>
</tr>
<tr>
<td><code>continue</code></td>
<td>Pula para a pr√≥xima itera√ß√£o</td>
<td><code>if condi√ß√£o { continue }</code></td>
</tr>
</tbody>
</table>
<h3 id="padr√µes-comuns">Padr√µes Comuns</h3>
<table>
<thead>
<tr>
<th>Padr√£o</th>
<th>C√≥digo</th>
<th>Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td>Processamento at√© condi√ß√£o</td>
<td><code>for !condi√ß√£o { ... }</code></td>
<td>Continuar at√© que algo aconte√ßa</td>
</tr>
<tr>
<td>Valida√ß√£o de entrada</td>
<td><code>for { input; if v√°lido { break } }</code></td>
<td>Repetir at√© entrada v√°lida</td>
</tr>
<tr>
<td>Busca em cole√ß√£o</td>
<td><code>for i &lt; len(cole√ß√£o) { if encontrado { break }; i++ }</code></td>
<td>Procurar um item</td>
</tr>
</tbody>
</table>
<h3 id="compara√ß√£o-la√ßos-com-contador-vs-la√ßos-com-condi√ß√£o">Compara√ß√£o: La√ßos com Contador vs. La√ßos com Condi√ß√£o</h3>
<table>
<thead>
<tr>
<th>La√ßo com Contador</th>
<th>La√ßo com Condi√ß√£o</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for i := 0; i &lt; n; i++ { ... }</code></td>
<td><code>for condi√ß√£o { ... }</code></td>
</tr>
<tr>
<td>N√∫mero fixo de itera√ß√µes</td>
<td>N√∫mero vari√°vel de itera√ß√µes</td>
</tr>
<tr>
<td>Ideal para arrays e slices</td>
<td>Ideal para processamento condicional</td>
</tr>
<tr>
<td>Vari√°vel de controle autom√°tica</td>
<td>Vari√°vel de controle manual</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="12-modelos-de-c√≥digo">12. Modelos de C√≥digo</h2>
<h3 id="modelo-1-la√ßo-condicional-b√°sico">Modelo 1: La√ßo Condicional B√°sico</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // La√ßo condicional b√°sico
    contador := 1

    for contador &lt;= 5 {
        fmt.Println(contador)
        contador++
    }
}
</code></pre>
<h3 id="modelo-2-valida√ß√£o-de-entrada">Modelo 2: Valida√ß√£o de Entrada</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var entrada int

    // Loop at√© receber entrada v√°lida
    for {
        fmt.Print(&quot;Digite um n√∫mero positivo: &quot;)
        fmt.Scanln(&amp;entrada)

        if entrada &gt; 0 {
            break
        }

        fmt.Println(&quot;Entrada inv√°lida! O n√∫mero deve ser positivo.&quot;)
    }

    fmt.Printf(&quot;Voc√™ digitou: %d\n&quot;, entrada)
}
</code></pre>
<h3 id="modelo-3-processamento-at√©-condi√ß√£o">Modelo 3: Processamento at√© Condi√ß√£o</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    soma := 0
    numero := 1

    // Somar n√∫meros at√© ultrapassar 100
    for soma &lt;= 100 {
        soma += numero
        fmt.Printf(&quot;Adicionando %d: soma = %d\n&quot;, numero, soma)
        numero++
    }

    fmt.Printf(&quot;A soma final √© %d\n&quot;, soma)
}
</code></pre>
<h3 id="modelo-4-simula√ß√£o-de-do-while">Modelo 4: Simula√ß√£o de Do-While</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    contador := 1

    // Simulando do-while
    for {
        fmt.Println(contador)
        contador++

        // Condi√ß√£o de sa√≠da verificada ap√≥s a execu√ß√£o
        if contador &gt; 5 {
            break
        }
    }
}
</code></pre>
<hr />
<p><strong>Gabarito do Quiz:</strong>
1. c) <code>for condi√ß√£o { c√≥digo }</code>
2. b) O loop n√£o executa nenhuma vez
3. b) <code>for { c√≥digo; if (!condi√ß√£o) break; }</code>
4. b) Pula para a pr√≥xima itera√ß√£o do loop
5. c) La√ßos com contador executam um n√∫mero predefinido de vezes</p>
  </article>
</main>

</body>
</html>