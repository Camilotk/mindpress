<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aula 7: Condicional Switch</title>
  <link rel="stylesheet" href="themes/rustbook/css/water-dark.css">
  <link rel="stylesheet" href="themes/rustbook/css/theme.css">
  <script src="themes/rustbook/js/theme.js" defer></script>
</head>
<body>

<aside>
  <header><h1>Curso de Algoritmos com Go</h1></header>
  <nav aria-label="Conte√∫do do curso">
    <ul>
      <li><a href="index.html">üìö √çndice Geral</a></li>
      <li><a href="algoritmos-base.html">Aula 1: Algoritmos ‚Äì A Base de Tudo!</a></li>
      <li><a href="break-e-continue.html">Aula 10: Break e Continue</a></li>
      <li><a href="condicional-if-else.html">Aula 6: Condicional If/Else</a></li>
      <li><a href="condicional-switch.html">Aula 7: Condicional Switch</a></li>
      <li><a href="entrada-e-saida.html">Aula 4: Entrada e Sa√≠da com Go</a></li>
      <li><a href="estrutura-sequencial.html">Aula 5: Estrutura Sequencial</a></li>
      <li><a href="identificadores-operadores.html">Aula 3: Identificadores e Operadores</a></li>
      <li><a href="nova_aula.html">Nova aula</a></li>
      <li><a href="repeticao-for.html">Aula 8: Repeti√ß√£o com For</a></li>
      <li><a href="variaveis-e-tipos.html">Aula 2: Vari√°veis e Tipos de Dados em Go</a></li>
      <li><a href="while-com-for.html">Aula 9: While com For</a></li>
    </ul>
  </nav>
</aside>

<main>
  <article>
    <h2>Aula 7: Condicional Switch</h2>
    <nav class="minimap"><ul><li class="lvl2"><a href="#objetivos-da-aula">Objetivos da Aula</a></li><li class="lvl2"><a href="#1-introdu√ß√£o-ao-code-switch-code">1. Introdu√ß√£o ao <code>switch</code></a></li><li class="lvl3"><a href="#1-1-o-que-√©-a-estrutura-code-switch-code">1.1. O que √© a Estrutura <code>switch</code>?</a></li><li class="lvl3"><a href="#1-2-por-que-usar-code-switch-code-em-vez-de-code-if-code-code-else-if-code-code-else-code">1.2. Por que Usar <code>switch</code> em vez de <code>if</code>-<code>else if</code>-<code>else</code>?</a></li><li class="lvl2"><a href="#2-sintaxe-do-code-switch-code-em-go">2. Sintaxe do <code>switch</code> em Go</a></li><li class="lvl3"><a href="#2-1-estrutura-b√°sica">2.1. Estrutura B√°sica</a></li><li class="lvl3"><a href="#2-2-caracter√≠sticas-do-code-switch-code-em-go">2.2. Caracter√≠sticas do <code>switch</code> em Go</a></li><li class="lvl3"><a href="#2-3-exemplo-b√°sico">2.3. Exemplo B√°sico</a></li><li class="lvl2"><a href="#3-varia√ß√µes-do-code-switch-code-em-go">3. Varia√ß√µes do <code>switch</code> em Go</a></li><li class="lvl3"><a href="#3-1-code-switch-code-com-m√∫ltiplos-valores-por-caso">3.1. <code>switch</code> com M√∫ltiplos Valores por Caso</a></li><li class="lvl3"><a href="#3-2-code-switch-code-sem-express√£o">3.2. <code>switch</code> sem Express√£o</a></li><li class="lvl3"><a href="#3-3-code-switch-code-com-inicializa√ß√£o">3.3. <code>switch</code> com Inicializa√ß√£o</a></li><li class="lvl3"><a href="#3-4-code-switch-code-com-tipo-type-switch">3.4. <code>switch</code> com Tipo (Type Switch)</a></li><li class="lvl2"><a href="#4-a-instru√ß√£o-code-fallthrough-code">4. A Instru√ß√£o <code>fallthrough</code></a></li><li class="lvl3"><a href="#4-1-o-que-√©-code-fallthrough-code">4.1. O que √© <code>fallthrough</code>?</a></li><li class="lvl3"><a href="#4-2-exemplo-de-code-fallthrough-code">4.2. Exemplo de <code>fallthrough</code></a></li><li class="lvl3"><a href="#4-3-limita√ß√µes-do-code-fallthrough-code">4.3. Limita√ß√µes do <code>fallthrough</code></a></li><li class="lvl3"><a href="#4-4-quando-usar-code-fallthrough-code">4.4. Quando Usar <code>fallthrough</code></a></li><li class="lvl2"><a href="#5-exemplos-pr√°ticos">5. Exemplos Pr√°ticos</a></li><li class="lvl3"><a href="#5-1-menu-de-op√ß√µes">5.1. Menu de Op√ß√µes</a></li><li class="lvl3"><a href="#5-2-calculadora-simples">5.2. Calculadora Simples</a></li><li class="lvl3"><a href="#5-3-verifica√ß√£o-de-dia-da-semana">5.3. Verifica√ß√£o de Dia da Semana</a></li><li class="lvl3"><a href="#5-4-classifica√ß√£o-de-notas">5.4. Classifica√ß√£o de Notas</a></li><li class="lvl2"><a href="#6-boas-pr√°ticas-com-code-switch-code">6. Boas Pr√°ticas com <code>switch</code></a></li><li class="lvl3"><a href="#6-1-quando-usar-code-switch-code-vs-code-if-code-code-else-if-code-code-else-code">6.1. Quando Usar <code>switch</code> vs. <code>if</code>-<code>else if</code>-<code>else</code></a></li><li class="lvl3"><a href="#6-2-ordem-dos-casos">6.2. Ordem dos Casos</a></li><li class="lvl3"><a href="#6-3-use-o-code-default-code-apropriadamente">6.3. Use o <code>default</code> Apropriadamente</a></li><li class="lvl3"><a href="#6-4-evite-code-fallthrough-code-quando-poss√≠vel">6.4. Evite <code>fallthrough</code> Quando Poss√≠vel</a></li><li class="lvl3"><a href="#6-5-mantenha-os-casos-simples">6.5. Mantenha os Casos Simples</a></li><li class="lvl2"><a href="#7-exerc√≠cios-offline">7. Exerc√≠cios Offline</a></li><li class="lvl2"><a href="#8-quiz-r√°pido">8. Quiz R√°pido</a></li><li class="lvl2"><a href="#9-desafio-pr√°tico-conversor-de-notas">9. Desafio Pr√°tico: Conversor de Notas</a></li><li class="lvl2"><a href="#10-resumo-da-aula">10. Resumo da Aula</a></li><li class="lvl2"><a href="#11-ficha-de-refer√™ncia-r√°pida">11. Ficha de Refer√™ncia R√°pida</a></li><li class="lvl3"><a href="#sintaxe-do-code-switch-code-em-go">Sintaxe do <code>switch</code> em Go</a></li><li class="lvl3"><a href="#varia√ß√µes-do-code-switch-code">Varia√ß√µes do <code>switch</code></a></li><li class="lvl3"><a href="#instru√ß√£o-code-fallthrough-code">Instru√ß√£o <code>fallthrough</code></a></li><li class="lvl3"><a href="#compara√ß√£o-com-code-if-code-code-else-if-code-code-else-code">Compara√ß√£o com <code>if</code>-<code>else if</code>-<code>else</code></a></li><li class="lvl2"><a href="#12-modelos-de-c√≥digo">12. Modelos de C√≥digo</a></li><li class="lvl3"><a href="#modelo-1-code-switch-code-b√°sico">Modelo 1: <code>switch</code> B√°sico</a></li><li class="lvl3"><a href="#modelo-2-code-switch-code-com-m√∫ltiplos-valores">Modelo 2: <code>switch</code> com M√∫ltiplos Valores</a></li><li class="lvl3"><a href="#modelo-3-code-switch-code-sem-express√£o">Modelo 3: <code>switch</code> sem Express√£o</a></li><li class="lvl3"><a href="#modelo-4-code-switch-code-com-code-fallthrough-code">Modelo 4: <code>switch</code> com <code>fallthrough</code></a></li></ul></nav><h1>Aula 7: Estrutura Condicional <code>switch</code> em Go</h1>
<h2 id="objetivos-da-aula">Objetivos da Aula</h2>
<p>Ao final desta aula, voc√™ ser√° capaz de:</p>
<ul>
<li>Compreender a estrutura condicional <code>switch</code> e suas vantagens em rela√ß√£o ao <code>if</code>-<code>else if</code>-<code>else</code></li>
<li>Utilizar a sintaxe do <code>switch</code>, <code>case</code> e <code>default</code> em Go</li>
<li>Aplicar o <code>switch</code> para resolver problemas com m√∫ltiplas condi√ß√µes</li>
<li>Implementar o <code>switch</code> com e sem express√£o de controle</li>
<li>Utilizar a instru√ß√£o <code>fallthrough</code> para controlar o fluxo de execu√ß√£o</li>
</ul>
<hr />
<h2 id="1-introdu√ß√£o-ao-code-switch-code">1. Introdu√ß√£o ao <code>switch</code></h2>
<h3 id="1-1-o-que-√©-a-estrutura-code-switch-code">1.1. O que √© a Estrutura <code>switch</code>?</h3>
<p>A estrutura <code>switch</code> √© uma forma elegante e eficiente de controlar o fluxo de um programa quando precisamos verificar m√∫ltiplas condi√ß√µes para uma mesma vari√°vel ou express√£o. Em vez de usar v√°rias instru√ß√µes <code>if</code>-<code>else if</code>-<code>else</code> encadeadas, o <code>switch</code> oferece uma sintaxe mais clara e concisa.</p>
<p>Pense no <code>switch</code> como um "seletor" que direciona o fluxo do programa para diferentes caminhos com base no valor de uma express√£o.</p>
<h3 id="1-2-por-que-usar-code-switch-code-em-vez-de-code-if-code-code-else-if-code-code-else-code">1.2. Por que Usar <code>switch</code> em vez de <code>if</code>-<code>else if</code>-<code>else</code>?</h3>
<p>Embora seja poss√≠vel resolver os mesmos problemas usando <code>if</code>-<code>else if</code>-<code>else</code>, o <code>switch</code> oferece v√°rias vantagens:</p>
<ol>
<li><strong>Legibilidade</strong>: O c√≥digo fica mais organizado e f√°cil de ler, especialmente quando h√° muitas condi√ß√µes.</li>
<li><strong>Manuten√ß√£o</strong>: √â mais f√°cil adicionar ou remover casos sem afetar a estrutura geral.</li>
<li><strong>Performance</strong>: Em algumas linguagens, o <code>switch</code> pode ser mais eficiente que m√∫ltiplos <code>if</code>-<code>else if</code>.</li>
<li><strong>Clareza de inten√ß√£o</strong>: O <code>switch</code> deixa claro que estamos verificando diferentes valores de uma mesma vari√°vel.</li>
</ol>
<p>Vamos comparar as duas abordagens:</p>
<p><strong>Usando <code>if</code>-<code>else if</code>-<code>else</code>:</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    diaSemana := 3

    if diaSemana == 1 {
        fmt.Println(&quot;Domingo&quot;)
    } else if diaSemana == 2 {
        fmt.Println(&quot;Segunda-feira&quot;)
    } else if diaSemana == 3 {
        fmt.Println(&quot;Ter√ßa-feira&quot;)
    } else if diaSemana == 4 {
        fmt.Println(&quot;Quarta-feira&quot;)
    } else if diaSemana == 5 {
        fmt.Println(&quot;Quinta-feira&quot;)
    } else if diaSemana == 6 {
        fmt.Println(&quot;Sexta-feira&quot;)
    } else if diaSemana == 7 {
        fmt.Println(&quot;S√°bado&quot;)
    } else {
        fmt.Println(&quot;Dia inv√°lido&quot;)
    }
}
</code></pre>
<p><strong>Usando <code>switch</code>:</strong></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    diaSemana := 3

    switch diaSemana {
    case 1:
        fmt.Println(&quot;Domingo&quot;)
    case 2:
        fmt.Println(&quot;Segunda-feira&quot;)
    case 3:
        fmt.Println(&quot;Ter√ßa-feira&quot;)
    case 4:
        fmt.Println(&quot;Quarta-feira&quot;)
    case 5:
        fmt.Println(&quot;Quinta-feira&quot;)
    case 6:
        fmt.Println(&quot;Sexta-feira&quot;)
    case 7:
        fmt.Println(&quot;S√°bado&quot;)
    default:
        fmt.Println(&quot;Dia inv√°lido&quot;)
    }
}
</code></pre>
<p>Ambos os c√≥digos produzem o mesmo resultado, mas o <code>switch</code> √© mais limpo e direto.</p>
<hr />
<h2 id="2-sintaxe-do-code-switch-code-em-go">2. Sintaxe do <code>switch</code> em Go</h2>
<h3 id="2-1-estrutura-b√°sica">2.1. Estrutura B√°sica</h3>
<p>A sintaxe b√°sica do <code>switch</code> em Go √©:</p>
<pre><code class="language-go">switch express√£o {
case valor1:
    // C√≥digo a ser executado se express√£o == valor1
case valor2:
    // C√≥digo a ser executado se express√£o == valor2
case valor3, valor4:
    // C√≥digo a ser executado se express√£o == valor3 ou express√£o == valor4
default:
    // C√≥digo a ser executado se nenhum dos casos anteriores for verdadeiro
}
</code></pre>
<p>Onde:
- <code>express√£o</code> √© avaliada uma √∫nica vez
- <code>case</code> define um valor ou lista de valores a serem comparados com a express√£o
- <code>default</code> √© opcional e executa quando nenhum <code>case</code> corresponde √† express√£o</p>
<h3 id="2-2-caracter√≠sticas-do-code-switch-code-em-go">2.2. Caracter√≠sticas do <code>switch</code> em Go</h3>
<p>O <code>switch</code> em Go tem algumas caracter√≠sticas especiais que o diferenciam de outras linguagens:</p>
<ol>
<li>
<p><strong>N√£o precisa de <code>break</code></strong>: Em Go, apenas o caso correspondente √© executado. N√£o h√° "queda" (fallthrough) autom√°tica para o pr√≥ximo caso, como em C ou Java.</p>
</li>
<li>
<p><strong>Casos podem ter m√∫ltiplos valores</strong>: Voc√™ pode listar v√°rios valores em um √∫nico <code>case</code>, separados por v√≠rgulas.</p>
</li>
<li>
<p><strong>Express√£o √© opcional</strong>: O <code>switch</code> pode ser usado sem uma express√£o, funcionando como uma alternativa mais limpa para <code>if</code>-<code>else if</code>-<code>else</code>.</p>
</li>
<li>
<p><strong>Casos podem ser express√µes</strong>: Os casos n√£o precisam ser constantes; podem ser express√µes que s√£o avaliadas durante a execu√ß√£o.</p>
</li>
</ol>
<h3 id="2-3-exemplo-b√°sico">2.3. Exemplo B√°sico</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    nota := 'B'

    switch nota {
    case 'A':
        fmt.Println(&quot;Excelente!&quot;)
    case 'B':
        fmt.Println(&quot;Muito bom!&quot;)
    case 'C':
        fmt.Println(&quot;Bom, mas pode melhorar.&quot;)
    case 'D':
        fmt.Println(&quot;Passou por pouco.&quot;)
    case 'F':
        fmt.Println(&quot;Reprovado.&quot;)
    default:
        fmt.Println(&quot;Nota inv√°lida.&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Muito bom!
</code></pre>
<p>Neste exemplo, o valor de <code>nota</code> √© comparado com cada <code>case</code>. Como <code>nota</code> √© 'B', o segundo caso √© executado.</p>
<hr />
<h2 id="3-varia√ß√µes-do-code-switch-code-em-go">3. Varia√ß√µes do <code>switch</code> em Go</h2>
<h3 id="3-1-code-switch-code-com-m√∫ltiplos-valores-por-caso">3.1. <code>switch</code> com M√∫ltiplos Valores por Caso</h3>
<p>Em Go, voc√™ pode listar m√∫ltiplos valores em um √∫nico <code>case</code>, separados por v√≠rgulas:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    diaSemana := 6

    switch diaSemana {
    case 1:
        fmt.Println(&quot;Domingo&quot;)
    case 2:
        fmt.Println(&quot;Segunda-feira&quot;)
    case 3:
        fmt.Println(&quot;Ter√ßa-feira&quot;)
    case 4:
        fmt.Println(&quot;Quarta-feira&quot;)
    case 5:
        fmt.Println(&quot;Quinta-feira&quot;)
    case 6, 7:
        fmt.Println(&quot;Fim de semana!&quot;)
    default:
        fmt.Println(&quot;Dia inv√°lido&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Fim de semana!
</code></pre>
<p>Neste exemplo, tanto o caso 6 quanto o caso 7 executam o mesmo bloco de c√≥digo.</p>
<h3 id="3-2-code-switch-code-sem-express√£o">3.2. <code>switch</code> sem Express√£o</h3>
<p>Em Go, voc√™ pode usar o <code>switch</code> sem uma express√£o, o que o torna uma alternativa mais limpa para <code>if</code>-<code>else if</code>-<code>else</code>:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    idade := 18

    switch {
    case idade &lt; 0:
        fmt.Println(&quot;Idade inv√°lida&quot;)
    case idade &lt; 18:
        fmt.Println(&quot;Menor de idade&quot;)
    case idade == 18:
        fmt.Println(&quot;Acabou de atingir a maioridade&quot;)
    case idade &lt; 60:
        fmt.Println(&quot;Adulto&quot;)
    default:
        fmt.Println(&quot;Idoso&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Acabou de atingir a maioridade
</code></pre>
<p>Neste exemplo, n√£o h√° express√£o ap√≥s a palavra-chave <code>switch</code>. Cada <code>case</code> √© uma express√£o booleana completa, e o primeiro caso verdadeiro √© executado.</p>
<h3 id="3-3-code-switch-code-com-inicializa√ß√£o">3.3. <code>switch</code> com Inicializa√ß√£o</h3>
<p>Assim como no <code>if</code>, voc√™ pode inicializar uma vari√°vel diretamente na instru√ß√£o <code>switch</code>:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    switch hora := 14; {
    case hora &lt; 12:
        fmt.Println(&quot;Bom dia!&quot;)
    case hora &lt; 18:
        fmt.Println(&quot;Boa tarde!&quot;)
    default:
        fmt.Println(&quot;Boa noite!&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Boa tarde!
</code></pre>
<p>Neste exemplo, a vari√°vel <code>hora</code> √© inicializada com o valor 14 e s√≥ existe dentro do escopo do <code>switch</code>.</p>
<h3 id="3-4-code-switch-code-com-tipo-type-switch">3.4. <code>switch</code> com Tipo (Type Switch)</h3>
<p>Go tamb√©m suporta um tipo especial de <code>switch</code> que verifica o tipo de uma interface:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func descreverTipo(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf(&quot;O valor %v √© um inteiro\n&quot;, v)
    case string:
        fmt.Printf(&quot;O valor %v √© uma string\n&quot;, v)
    case bool:
        fmt.Printf(&quot;O valor %v √© um booleano\n&quot;, v)
    default:
        fmt.Printf(&quot;O valor %v √© de um tipo desconhecido\n&quot;, v)
    }
}

func main() {
    descreverTipo(42)
    descreverTipo(&quot;Ol√°&quot;)
    descreverTipo(true)
    descreverTipo(3.14)
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>O valor 42 √© um inteiro
O valor Ol√° √© uma string
O valor true √© um booleano
O valor 3.14 √© de um tipo desconhecido
</code></pre>
<p>Este tipo de <code>switch</code> √© √∫til quando voc√™ est√° trabalhando com interfaces e precisa executar diferentes a√ß√µes com base no tipo concreto do valor.</p>
<hr />
<h2 id="4-a-instru√ß√£o-code-fallthrough-code">4. A Instru√ß√£o <code>fallthrough</code></h2>
<h3 id="4-1-o-que-√©-code-fallthrough-code">4.1. O que √© <code>fallthrough</code>?</h3>
<p>Em muitas linguagens de programa√ß√£o (como C, C++, Java), o <code>switch</code> tem um comportamento de "queda" (fallthrough) autom√°tico, onde a execu√ß√£o continua para o pr√≥ximo caso a menos que um <code>break</code> seja encontrado.</p>
<p>Em Go, o comportamento padr√£o √© o oposto: apenas o caso correspondente √© executado, e a execu√ß√£o sai do <code>switch</code> automaticamente. No entanto, Go oferece a instru√ß√£o <code>fallthrough</code> para for√ßar a execu√ß√£o a continuar para o pr√≥ximo caso.</p>
<h3 id="4-2-exemplo-de-code-fallthrough-code">4.2. Exemplo de <code>fallthrough</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    numero := 2

    fmt.Println(&quot;Contando de&quot;, numero, &quot;at√© 5:&quot;)

    switch numero {
    case 1:
        fmt.Println(&quot;Um&quot;)
        fallthrough
    case 2:
        fmt.Println(&quot;Dois&quot;)
        fallthrough
    case 3:
        fmt.Println(&quot;Tr√™s&quot;)
        fallthrough
    case 4:
        fmt.Println(&quot;Quatro&quot;)
        fallthrough
    case 5:
        fmt.Println(&quot;Cinco&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Contando de 2 at√© 5:
Dois
Tr√™s
Quatro
Cinco
</code></pre>
<p>Neste exemplo, a execu√ß√£o come√ßa no caso 2 (porque <code>numero</code> √© 2) e continua para os casos seguintes devido √† instru√ß√£o <code>fallthrough</code>.</p>
<h3 id="4-3-limita√ß√µes-do-code-fallthrough-code">4.3. Limita√ß√µes do <code>fallthrough</code></h3>
<p>√â importante notar que o <code>fallthrough</code> em Go tem algumas limita√ß√µes:</p>
<ol>
<li>Ele deve ser a √∫ltima instru√ß√£o em um caso.</li>
<li>Ele n√£o pode ser usado no √∫ltimo caso de um <code>switch</code>.</li>
<li>Ele n√£o pode ser usado em um <code>switch</code> de tipo (type switch).</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    valor := 1

    switch valor {
    case 1:
        fmt.Println(&quot;Um&quot;)
        // Isso funciona porque fallthrough √© a √∫ltima instru√ß√£o
        fallthrough
    case 2:
        fmt.Println(&quot;Menor ou igual a dois&quot;)
        // Isso N√ÉO compilaria:
        // fmt.Println(&quot;Teste&quot;)
        // fallthrough
    case 3:
        fmt.Println(&quot;Menor ou igual a tr√™s&quot;)
    }
}
</code></pre>
<p>Sa√≠da:</p>
<pre><code>Um
Menor ou igual a dois
</code></pre>
<h3 id="4-4-quando-usar-code-fallthrough-code">4.4. Quando Usar <code>fallthrough</code></h3>
<p>O <code>fallthrough</code> deve ser usado com cautela, pois pode tornar o c√≥digo menos previs√≠vel. Alguns casos de uso leg√≠timos incluem:</p>
<ol>
<li>Quando voc√™ quer executar o mesmo c√≥digo para v√°rios casos consecutivos.</li>
<li>Quando voc√™ est√° implementando uma m√°quina de estados onde cada estado leva ao pr√≥ximo.</li>
<li>Quando voc√™ est√° portando c√≥digo de outras linguagens que dependem desse comportamento.</li>
</ol>
<hr />
<h2 id="5-exemplos-pr√°ticos">5. Exemplos Pr√°ticos</h2>
<h3 id="5-1-menu-de-op√ß√µes">5.1. Menu de Op√ß√µes</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Menu:&quot;)
    fmt.Println(&quot;1. Ver saldo&quot;)
    fmt.Println(&quot;2. Fazer dep√≥sito&quot;)
    fmt.Println(&quot;3. Fazer saque&quot;)
    fmt.Println(&quot;4. Sair&quot;)

    var opcao int
    fmt.Print(&quot;Escolha uma op√ß√£o: &quot;)
    fmt.Scanln(&amp;opcao)

    switch opcao {
    case 1:
        fmt.Println(&quot;Seu saldo √© R$ 1000,00&quot;)
    case 2:
        fmt.Println(&quot;Digite o valor do dep√≥sito:&quot;)
        // C√≥digo para dep√≥sito
    case 3:
        fmt.Println(&quot;Digite o valor do saque:&quot;)
        // C√≥digo para saque
    case 4:
        fmt.Println(&quot;Saindo do sistema...&quot;)
    default:
        fmt.Println(&quot;Op√ß√£o inv√°lida!&quot;)
    }
}
</code></pre>
<p>Este exemplo simula um menu de banco simples, onde cada op√ß√£o executa uma a√ß√£o diferente.</p>
<h3 id="5-2-calculadora-simples">5.2. Calculadora Simples</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var num1, num2 float64
    var operador string

    fmt.Print(&quot;Digite o primeiro n√∫mero: &quot;)
    fmt.Scanln(&amp;num1)

    fmt.Print(&quot;Digite o segundo n√∫mero: &quot;)
    fmt.Scanln(&amp;num2)

    fmt.Print(&quot;Digite o operador (+, -, *, /): &quot;)
    fmt.Scanln(&amp;operador)

    switch operador {
    case &quot;+&quot;:
        fmt.Printf(&quot;%.2f + %.2f = %.2f\n&quot;, num1, num2, num1+num2)
    case &quot;-&quot;:
        fmt.Printf(&quot;%.2f - %.2f = %.2f\n&quot;, num1, num2, num1-num2)
    case &quot;*&quot;:
        fmt.Printf(&quot;%.2f * %.2f = %.2f\n&quot;, num1, num2, num1*num2)
    case &quot;/&quot;:
        if num2 == 0 {
            fmt.Println(&quot;Erro: Divis√£o por zero!&quot;)
        } else {
            fmt.Printf(&quot;%.2f / %.2f = %.2f\n&quot;, num1, num2, num1/num2)
        }
    default:
        fmt.Println(&quot;Operador inv√°lido!&quot;)
    }
}
</code></pre>
<p>Esta calculadora simples usa o <code>switch</code> para executar diferentes opera√ß√µes com base no operador fornecido.</p>
<h3 id="5-3-verifica√ß√£o-de-dia-da-semana">5.3. Verifica√ß√£o de Dia da Semana</h3>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    hoje := time.Now()
    diaDaSemana := hoje.Weekday()

    switch diaDaSemana {
    case time.Monday:
        fmt.Println(&quot;Hoje √© Segunda-feira&quot;)
    case time.Tuesday:
        fmt.Println(&quot;Hoje √© Ter√ßa-feira&quot;)
    case time.Wednesday:
        fmt.Println(&quot;Hoje √© Quarta-feira&quot;)
    case time.Thursday:
        fmt.Println(&quot;Hoje √© Quinta-feira&quot;)
    case time.Friday:
        fmt.Println(&quot;Hoje √© Sexta-feira&quot;)
    case time.Saturday, time.Sunday:
        fmt.Println(&quot;Hoje √© fim de semana!&quot;)
    }

    // Verificando se √© dia √∫til ou fim de semana
    switch diaDaSemana {
    case time.Saturday, time.Sunday:
        fmt.Println(&quot;√â fim de semana! Aproveite!&quot;)
    default:
        fmt.Println(&quot;√â dia √∫til. Bom trabalho!&quot;)
    }
}
</code></pre>
<p>Este exemplo usa o pacote <code>time</code> para obter o dia atual da semana e exibe mensagens diferentes com base nesse valor.</p>
<h3 id="5-4-classifica√ß√£o-de-notas">5.4. Classifica√ß√£o de Notas</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    nota := 85

    switch {
    case nota &gt;= 90:
        fmt.Println(&quot;A&quot;)
    case nota &gt;= 80:
        fmt.Println(&quot;B&quot;)
    case nota &gt;= 70:
        fmt.Println(&quot;C&quot;)
    case nota &gt;= 60:
        fmt.Println(&quot;D&quot;)
    default:
        fmt.Println(&quot;F&quot;)
    }

    // Outra forma, usando switch com express√£o
    var conceito string

    switch {
    case nota &gt;= 90:
        conceito = &quot;A&quot;
    case nota &gt;= 80:
        conceito = &quot;B&quot;
    case nota &gt;= 70:
        conceito = &quot;C&quot;
    case nota &gt;= 60:
        conceito = &quot;D&quot;
    default:
        conceito = &quot;F&quot;
    }

    switch conceito {
    case &quot;A&quot;, &quot;B&quot;:
        fmt.Println(&quot;Aprovado com excel√™ncia!&quot;)
    case &quot;C&quot;:
        fmt.Println(&quot;Aprovado.&quot;)
    case &quot;D&quot;:
        fmt.Println(&quot;Aprovado, mas precisa melhorar.&quot;)
    case &quot;F&quot;:
        fmt.Println(&quot;Reprovado.&quot;)
    }
}
</code></pre>
<p>Este exemplo classifica uma nota num√©rica em um conceito de letra e, em seguida, fornece feedback com base nesse conceito.</p>
<hr />
<h2 id="6-boas-pr√°ticas-com-code-switch-code">6. Boas Pr√°ticas com <code>switch</code></h2>
<h3 id="6-1-quando-usar-code-switch-code-vs-code-if-code-code-else-if-code-code-else-code">6.1. Quando Usar <code>switch</code> vs. <code>if</code>-<code>else if</code>-<code>else</code></h3>
<ul>
<li>Use <code>switch</code> quando estiver verificando m√∫ltiplos valores de uma mesma vari√°vel.</li>
<li>Use <code>switch</code> sem express√£o quando tiver m√∫ltiplas condi√ß√µes booleanas independentes.</li>
<li>Use <code>if</code>-<code>else if</code>-<code>else</code> quando as condi√ß√µes forem complexas ou n√£o relacionadas.</li>
</ul>
<h3 id="6-2-ordem-dos-casos">6.2. Ordem dos Casos</h3>
<p>Organize os casos em uma ordem l√≥gica:
- Para valores num√©ricos, considere a ordem crescente ou decrescente.
- Para strings, considere a ordem alfab√©tica ou a frequ√™ncia de ocorr√™ncia.
- Coloque os casos mais comuns primeiro para melhorar a efici√™ncia.</p>
<h3 id="6-3-use-o-code-default-code-apropriadamente">6.3. Use o <code>default</code> Apropriadamente</h3>
<p>O caso <code>default</code> deve ser usado para:
- Tratar valores inesperados ou inv√°lidos.
- Fornecer um comportamento padr√£o quando nenhum caso espec√≠fico se aplica.
- Registrar ou relatar situa√ß√µes inesperadas.</p>
<h3 id="6-4-evite-code-fallthrough-code-quando-poss√≠vel">6.4. Evite <code>fallthrough</code> Quando Poss√≠vel</h3>
<p>Em vez de usar <code>fallthrough</code>, considere:
- Agrupar casos com a mesma l√≥gica (usando v√≠rgulas).
- Extrair a l√≥gica comum para uma fun√ß√£o separada.
- Usar vari√°veis para armazenar resultados intermedi√°rios.</p>
<h3 id="6-5-mantenha-os-casos-simples">6.5. Mantenha os Casos Simples</h3>
<p>Cada caso deve ser simples e focado:
- Evite l√≥gica complexa dentro dos casos.
- Considere extrair a l√≥gica para fun√ß√µes separadas se for muito complexa.
- Use coment√°rios para explicar casos n√£o √≥bvios.</p>
<hr />
<h2 id="7-exerc√≠cios-offline">7. Exerc√≠cios Offline</h2>
<ol>
<li>
<p><strong>Conversor de Meses</strong>: Escreva um algoritmo que, dado um n√∫mero de 1 a 12, retorne o nome do m√™s correspondente.</p>
</li>
<li>
<p><strong>Calculadora de Esta√ß√£o do Ano</strong>: Crie um algoritmo que, dado um m√™s (1 a 12) e um dia (1 a 31), determine a esta√ß√£o do ano no hemisf√©rio sul.</p>
</li>
<li>
<p><strong>Menu de Restaurante</strong>: Desenvolva um algoritmo que simule um menu de restaurante, onde o usu√°rio escolhe um prato pelo n√∫mero e o programa exibe o nome, pre√ßo e tempo de preparo.</p>
</li>
<li>
<p><strong>Calculadora de Desconto</strong>: Crie um algoritmo que aplique diferentes percentuais de desconto com base no valor da compra e no dia da semana.</p>
</li>
<li>
<p><strong>Verificador de Caractere</strong>: Desenvolva um algoritmo que classifique um caractere como letra mai√∫scula, letra min√∫scula, d√≠gito ou caractere especial.</p>
</li>
</ol>
<hr />
<h2 id="8-quiz-r√°pido">8. Quiz R√°pido</h2>
<ol>
<li>
<p>Qual √© a principal vantagem do <code>switch</code> em rela√ß√£o ao <code>if</code>-<code>else if</code>-<code>else</code>?
   a) O <code>switch</code> √© sempre mais r√°pido
   b) O <code>switch</code> permite mais condi√ß√µes
   c) O <code>switch</code> oferece melhor legibilidade para m√∫ltiplas condi√ß√µes relacionadas
   d) O <code>switch</code> usa menos mem√≥ria</p>
</li>
<li>
<p>Em Go, o que acontece ap√≥s a execu√ß√£o de um caso no <code>switch</code>?
   a) A execu√ß√£o continua para o pr√≥ximo caso automaticamente
   b) A execu√ß√£o sai do <code>switch</code> automaticamente
   c) √â necess√°rio usar <code>break</code> para sair do <code>switch</code>
   d) O programa termina</p>
</li>
<li>
<p>Para que serve a instru√ß√£o <code>fallthrough</code> em Go?
   a) Para sair do <code>switch</code>
   b) Para pular para um caso espec√≠fico
   c) Para continuar a execu√ß√£o no pr√≥ximo caso
   d) Para retornar ao in√≠cio do <code>switch</code></p>
</li>
<li>
<p>Qual das seguintes afirma√ß√µes sobre o <code>switch</code> em Go √© FALSA?
   a) Voc√™ pode ter m√∫ltiplos valores em um √∫nico caso
   b) Voc√™ pode usar o <code>switch</code> sem uma express√£o
   c) Os casos devem ser constantes
   d) O caso <code>default</code> √© opcional</p>
</li>
<li>
<p>Em um <code>switch</code> sem express√£o em Go, o que √© verificado em cada caso?
   a) Nada, √© um erro de sintaxe
   b) O valor da √∫ltima vari√°vel declarada
   c) Uma express√£o booleana
   d) O valor de retorno da fun√ß√£o principal</p>
</li>
</ol>
<hr />
<h2 id="9-desafio-pr√°tico-conversor-de-notas">9. Desafio Pr√°tico: Conversor de Notas</h2>
<p>Crie um programa em Go que converta notas num√©ricas para diferentes sistemas de classifica√ß√£o. O programa deve:</p>
<ol>
<li>Declarar uma vari√°vel para armazenar uma nota de 0 a 100.</li>
<li>Usar um <code>switch</code> para converter a nota para o sistema de letras (A, B, C, D, F).</li>
<li>Usar outro <code>switch</code> para converter a nota para o sistema de conceitos (Excelente, Bom, Satisfat√≥rio, Regular, Insuficiente).</li>
<li>Usar um terceiro <code>switch</code> para determinar se o aluno foi aprovado, est√° em recupera√ß√£o ou foi reprovado.</li>
<li>Exibir todas as classifica√ß√µes.</li>
</ol>
<p><strong>Exemplo de Sa√≠da Esperada:</strong></p>
<pre><code>Nota: 85

Classifica√ß√µes:
- Sistema de Letras: B
- Sistema de Conceitos: Bom
- Situa√ß√£o: Aprovado
</code></pre>
<p><strong>Dica:</strong> Use o <code>switch</code> sem express√£o para verificar faixas de valores.</p>
<hr />
<h2 id="10-resumo-da-aula">10. Resumo da Aula</h2>
<p>Nesta aula, aprendemos sobre:</p>
<ul>
<li><strong>Estrutura <code>switch</code></strong>: Uma alternativa mais limpa e leg√≠vel ao <code>if</code>-<code>else if</code>-<code>else</code> para verificar m√∫ltiplas condi√ß√µes.</li>
<li><strong>Sintaxe B√°sica</strong>: <code>switch express√£o { case valor: c√≥digo }</code>.</li>
<li><strong>Caracter√≠sticas em Go</strong>:</li>
<li>N√£o h√° "queda" (fallthrough) autom√°tica para o pr√≥ximo caso.</li>
<li>Casos podem ter m√∫ltiplos valores separados por v√≠rgulas.</li>
<li>O <code>switch</code> pode ser usado sem uma express√£o.</li>
<li>Casos podem ser express√µes, n√£o apenas constantes.</li>
<li><strong>Varia√ß√µes</strong>:</li>
<li><code>switch</code> com m√∫ltiplos valores por caso.</li>
<li><code>switch</code> sem express√£o.</li>
<li><code>switch</code> com inicializa√ß√£o.</li>
<li><code>switch</code> de tipo (type switch).</li>
<li><strong>Instru√ß√£o <code>fallthrough</code></strong>: For√ßa a execu√ß√£o a continuar para o pr√≥ximo caso.</li>
<li><strong>Boas Pr√°ticas</strong>: Quando usar <code>switch</code> vs. <code>if</code>-<code>else if</code>-<code>else</code>, ordem dos casos, uso apropriado do <code>default</code>, etc.</li>
</ul>
<p>O <code>switch</code> √© uma ferramenta poderosa que pode tornar seu c√≥digo mais limpo e mais f√°cil de entender, especialmente quando voc√™ est√° lidando com m√∫ltiplas condi√ß√µes relacionadas.</p>
<hr />
<h2 id="11-ficha-de-refer√™ncia-r√°pida">11. Ficha de Refer√™ncia R√°pida</h2>
<h3 id="sintaxe-do-code-switch-code-em-go">Sintaxe do <code>switch</code> em Go</h3>
<pre><code class="language-go">switch express√£o {
case valor1:
    // C√≥digo para valor1
case valor2, valor3:
    // C√≥digo para valor2 ou valor3
default:
    // C√≥digo para outros valores
}
</code></pre>
<h3 id="varia√ß√µes-do-code-switch-code">Varia√ß√µes do <code>switch</code></h3>
<table>
<thead>
<tr>
<th>Varia√ß√£o</th>
<th>Sintaxe</th>
<th>Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td>B√°sico</td>
<td><code>switch expr { case val: ... }</code></td>
<td>Comparar uma express√£o com m√∫ltiplos valores</td>
</tr>
<tr>
<td>M√∫ltiplos valores</td>
<td><code>case val1, val2, val3:</code></td>
<td>Executar o mesmo c√≥digo para v√°rios valores</td>
</tr>
<tr>
<td>Sem express√£o</td>
<td><code>switch { case cond1: ... }</code></td>
<td>Alternativa ao <code>if</code>-<code>else if</code>-<code>else</code></td>
</tr>
<tr>
<td>Com inicializa√ß√£o</td>
<td><code>switch var := valor; { ... }</code></td>
<td>Inicializar uma vari√°vel no escopo do <code>switch</code></td>
</tr>
<tr>
<td>De tipo</td>
<td><code>switch v := i.(type) { ... }</code></td>
<td>Verificar o tipo de uma interface</td>
</tr>
</tbody>
</table>
<h3 id="instru√ß√£o-code-fallthrough-code">Instru√ß√£o <code>fallthrough</code></h3>
<ul>
<li>Uso: <code>fallthrough</code> (deve ser a √∫ltima instru√ß√£o em um caso)</li>
<li>Efeito: Continua a execu√ß√£o no pr√≥ximo caso, independentemente da condi√ß√£o</li>
<li>Limita√ß√µes: N√£o pode ser usado no √∫ltimo caso ou em um <code>switch</code> de tipo</li>
</ul>
<h3 id="compara√ß√£o-com-code-if-code-code-else-if-code-code-else-code">Compara√ß√£o com <code>if</code>-<code>else if</code>-<code>else</code></h3>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th><code>switch</code></th>
<th><code>if</code>-<code>else if</code>-<code>else</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Legibilidade</td>
<td>Melhor para m√∫ltiplas condi√ß√µes relacionadas</td>
<td>Melhor para condi√ß√µes complexas</td>
</tr>
<tr>
<td>Expressividade</td>
<td>Casos podem ter m√∫ltiplos valores</td>
<td>Cada condi√ß√£o √© independente</td>
</tr>
<tr>
<td>Comportamento</td>
<td>Executa apenas o caso correspondente</td>
<td>Verifica todas as condi√ß√µes em ordem</td>
</tr>
<tr>
<td>Uso comum</td>
<td>Verificar valores de uma mesma vari√°vel</td>
<td>Verificar condi√ß√µes n√£o relacionadas</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="12-modelos-de-c√≥digo">12. Modelos de C√≥digo</h2>
<h3 id="modelo-1-code-switch-code-b√°sico">Modelo 1: <code>switch</code> B√°sico</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Vari√°vel para teste
    opcao := 2

    // Switch b√°sico
    switch opcao {
    case 1:
        fmt.Println(&quot;Op√ß√£o 1 selecionada&quot;)
    case 2:
        fmt.Println(&quot;Op√ß√£o 2 selecionada&quot;)
    case 3:
        fmt.Println(&quot;Op√ß√£o 3 selecionada&quot;)
    default:
        fmt.Println(&quot;Op√ß√£o inv√°lida&quot;)
    }
}
</code></pre>
<h3 id="modelo-2-code-switch-code-com-m√∫ltiplos-valores">Modelo 2: <code>switch</code> com M√∫ltiplos Valores</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Vari√°vel para teste
    diaSemana := &quot;s√°bado&quot;

    // Switch com m√∫ltiplos valores por caso
    switch diaSemana {
    case &quot;segunda-feira&quot;, &quot;ter√ßa-feira&quot;, &quot;quarta-feira&quot;, &quot;quinta-feira&quot;, &quot;sexta-feira&quot;:
        fmt.Println(&quot;Dia √∫til&quot;)
    case &quot;s√°bado&quot;, &quot;domingo&quot;:
        fmt.Println(&quot;Fim de semana&quot;)
    default:
        fmt.Println(&quot;Dia inv√°lido&quot;)
    }
}
</code></pre>
<h3 id="modelo-3-code-switch-code-sem-express√£o">Modelo 3: <code>switch</code> sem Express√£o</h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Vari√°vel para teste
    idade := 25

    // Switch sem express√£o
    switch {
    case idade &lt; 0:
        fmt.Println(&quot;Idade inv√°lida&quot;)
    case idade &lt; 18:
        fmt.Println(&quot;Menor de idade&quot;)
    case idade &lt; 60:
        fmt.Println(&quot;Adulto&quot;)
    default:
        fmt.Println(&quot;Idoso&quot;)
    }
}
</code></pre>
<h3 id="modelo-4-code-switch-code-com-code-fallthrough-code">Modelo 4: <code>switch</code> com <code>fallthrough</code></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // Vari√°vel para teste
    nivel := 2

    fmt.Println(&quot;N√≠veis de acesso concedidos:&quot;)

    // Switch com fallthrough
    switch nivel {
    case 3:
        fmt.Println(&quot;- Acesso de administrador&quot;)
        fallthrough
    case 2:
        fmt.Println(&quot;- Acesso de editor&quot;)
        fallthrough
    case 1:
        fmt.Println(&quot;- Acesso de leitura&quot;)
    default:
        fmt.Println(&quot;- Sem acesso&quot;)
    }
}
</code></pre>
<hr />
<p><strong>Gabarito do Quiz:</strong>
1. c) O <code>switch</code> oferece melhor legibilidade para m√∫ltiplas condi√ß√µes relacionadas
2. b) A execu√ß√£o sai do <code>switch</code> automaticamente
3. c) Para continuar a execu√ß√£o no pr√≥ximo caso
4. c) Os casos devem ser constantes
5. c) Uma express√£o booleana</p>
  </article>
</main>

</body>
</html>